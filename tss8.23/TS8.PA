/TS8 - UWM VERSION 23
/
/COPYRIGHT 1971			DIGITAL EQUIPMENT CORPORATION
/				MAYNARD, MASSACHUSETTS
/
/PAGE 0

FIELD 3				/LOAD THIS INTO TRACK 3 ON DISK
	*1
	JMP I .+1
	INT

WS0,	0	/WORKING STORAGE FOR MAIN FLOW
WS1,	0
JOBSWA,	0

T8AX1=	10	/680 SERVICE
T8AX2=	11	/680 SERVICE
L2Q=	13	/LEVEL 2 QUEUE
L2QE=	14	/LEVEL 2 QUEUE EMPTY POINTER
AXS1=	15	/MISCELLANEOUS LEVEL 2 AUTO-INDEX
AXS2=	16	/  "
DSKPTR=	17	/DISC REQUEST QUEUE POINTER
/SUBROUTINE DISPATCHES

SUBDSP=	DATEND
*SUBDSP

IOR=	JMS I .
	IOR0	/INCLUSIVE OR
UUOEXT=	JMP I .
	UUOEX1	/UUO EXIT
FIUSER,	DSUSER	/QUEUE FILE REQUEST IN DSUTBL
ERROR=	JMS I .
	SYSERR	/SYSTEM ERROR
TTYUSE=	JMS I .
	TTYSRC	/FIND USER TTY
SCHED=	JMP I .
	SCHEDI	/SCHEDULE NEXT JOB NOW CORE RESIDENT
RSCHED=	JMP I .
RSCHEA,SCHED0	/FIND NEXT JOB TO BE RUN
EXIT=	JMP I .
EXITA,	L2EXIT	/LEAVE LEVEL 2
REDO=	JMP I .
	REDO0	/REPEAT IOT LATER WHEN (HOPEFULLY) IT CAN BE COMPLETED
BREAK=	JMS I .
	BRKTST	/TEST IF CHARACTER IS A DELIMITER
GIR=	JMS I .
	GIR00	/ROUTE CHARACTERS TO JOBS AND TELETYPES
SAVJOB=	JMS I .
	SAVJO0	/SAVE THE STATUS OF THE CURRENT JOB
RESJOB=	JMS I .
	RESJO0	/RESTORE THE PREVIOUSLY SAVED STATUS
START=	JMP I .	/START USER JOB
	SUJ
DSGO=	JMS I .
	DSGO0	/START DISC REQUEST
GETJTW=	JMS I .
	GETJW0	/GET CONTENT OF JOB STATUS WORD (CURRENT JOB)
GETJTI=	JMS I .
	GETJI0	/GET CONTENT OF JOB STATUS WORD (ANY JOB)
DISMIS=	JMP I .
	DISMI0	/DISMIS INTERRUPTS
RUNABL=	JMS I .
	RUNTST	/TEST IF SPECIFIED JOB IS RUNABLE

L2CON=	SUBDSP+23	/LEVEL 2 (EXEC) CONTROL
*L2CON

L2SF,	.	/RELOCATION AND MODE
L2SV0,	.	/SAVED PC
L2SVLK,	.	/SAVED LINK
L2SA,	.	/SAVED ACCUMULATOR
TT8PG0=	L2CON+4		/680 CONSTANTS
	*TT8PG0
T8SL,	0		/-STARTING LINE NUMBER
T8NL,	-NULINE		/-NUMBER OF LINES
T8LN,	0
	*SOURCE
	.		/CHARACTER SOURCE FOR GIR

	IFZERO D680-2 <
T8INFL,   0          /INPUT READY FLAG
T8BFK,	T8IBF-1	    /TO RESET INPUT BUFFER POINTER
T8NUML,	NULINE		/NUMBER OF LINES
T8K0,	0
T8K7,     T8OBF      /K FOR 1ST OUTPUT BUFFER
T8OUTK,   T8OBF      /POINTER TO FIRST OUTPUT BUFFER
T8OTK2,   T8OBF2     /POINTER TO 2ND OUTPUT BUFFER
T8K14,	0
T8K36,    T8OBF2     /K FOR 2ND OUTPUT BUFFER
T8CNT1,   -10        /HOLD MAJOR LOOP COUNTER
T8CNT2,   0          /MINOR LOOP COUNTER
T8CNT3,   0          /COUNTER FOR INPUT BUFFER
T8K8,	T8COM
T8K99,	T8KFLL
T8SOF=	JMS I T8SOUT
T8SOUT,	T8OUTS
	>
	IFZERO D680 <
		IFNZRO CPU-3 <
TDEV,	TODEV-1	/START OF PT08 OUTPUT DEVICE CODE TABLE
KDEV,	TIDEV-1	/START OF PT08 INPUT DEVICE CODE TABLE
		>

		IFZERO CPU-3 <
DC02CH,	0			/FREQUENTLY USED CHARACTER WORD FOR DC02
		>

KBUFF,	TIBUFF	/INPUT CHARACTER BUFFER (INDEXED BY LINE #)
TBUFF,	TOBUFF	/OUTPUT CHARACTER BUFFER (INDEXED BY LINE #)
TBUFFE,	TOBUFF+NULINE	/END OF BUFFER
KBUFFE,	TIBUFF+NULINE	/END OF BUFFER
C6006,	6006
TSERI,	TSER	/PT08 INTERRUPT HANDLER-OUTPUT
KSERI,	KSER	/PT08 INTERRUPT HANDLER-INPUT

		IFNZRO CPU-3 <
INT21,	INT2	/PT08 INTERRUPT SEARCH
		>
REBOOT=	JMS I .
	RBOOT	/INITIATE AUTOMATIC SYSTEM RESTART

	*132		/SO REST OF PAGE 0 LINE UP
	>

KCHAR,	0	/CTY INPUT CHARACTER
TCHAR,	0	/CTY OUTPUT CHARACTER
	IFNZRO WRDSEG+7400	<GLITCH; *.-1>
C7400,
SEGLMK,	-WRDSEG	/MASK TO GET LOW-ORDER SEGMENT NUMBER
BASWIN,	-WINBAS-1

T8SIR=	JMS I T8SIN
T8SIN,    T8INS      /SKIP IF INPUT READY
CJOBDA=	JOBDAT
C0006,	6
C0070,	70
C0200,	200
C0377,	377
	IFNZRO WRDSEG-1-377	<GLITCH; *.-1>
SEGSM1=	C0377	/WRDSEG-1 (FOR GETTING ADDRESS WITHIN SEG)
PTRCHK,		/IS PTR ASSIGNED?
PTPCHK,	DEVCHK	/IS PTP ASSIGNED
C0600,	600
C6203,	6203
C7776,	7776
UUOERA,	UUOERR
	*UUDF-1
UDF=	JMS .	/SELECT FIELD OF CURRENT JOB
WS2,	0
	0	/DATA FIELD SELECT FOR FIELD OF CURRENT JOB
	JMP I .-2
INTRC,	0		/TRAC # TO BE SWAPPED IN (DF32 0X00 ) ( RF08 000X)
OUTTRC,	0		/TRAC # TO BE SWAPPED OUT
CNOTR,	-1-NOTRUN-FIX
*42 
FANCOR,	CORTBL+1		/FIELD OF PHANTOM  IE FIELD 2
*57
BONUS,	0		/JOB # JUST BROKEN OUT OF I/O WAIT

*157
SWPIOA,	SWPIO
*45
SWPGD2,	SWGOOD
	PAGE
/PRIORITY LEVEL 0 (HIGHEST PRIORITY)
/KEEPS TRACK OF REAL TIME
/ALWAYS ENTERED BY CLOCK FLAG
/DISMISSES TO LEVEL 1 IF INTERRUPT WAS NOT FROM LEVEL 1
/OTHERWISE, DISMISSES TO INTERRUPTED LOCATION.
/
INT,	SKPIOT		/USER IOT? (HAS TO BE CHECKED FIRST!!!)

	IFZERO D680 <
	JMP INT0	/NO - GO CHECK THE REST
	>
	IFZERO D680-2 <
	SKP		/NO - CHECK THE DC08
	>
	JMP I UUOA	/YES, GO SAVE LEVEL 2 STUFF

	IFZERO D680-2 <
	T8SKP		/CLOCK TICK?
	JMP INT0	/NO - KEEP LOOKING
	ISZ CLKCNT	/YES - IS A SYSTEM TICK UP YET?
	JMP I T8DISA	/NO - RUN DC08 INTERRUPT SERVICE
	DCA CLKIT	/YES - SAVE THE AC
	TAD L2TIMA
	JMS I L2QPSH	/ AND SCHEDULE 'L2TIME'
	TAD CLKIN1
	DCA CLKCNT	/RESET THE TICK COUNTER
	TAD CLKIN2
	DCA CLKIN1	/THEN SWAP COUNTERS SO SYSTEM CLOCK RATE
	TAD CLKCNT	/ IS THE SAME FOR ALL HARDWARE
	DCA CLKIN2
	TAD CLKIT	/GET AC AT INTERRUPT
	JMP I .+1	/RUN DC08 SERVICE
T8DISA,	T8DIS
CLKCNT,	-34
CLKIN1,	-33	/DIVIDE CLOCK RATE BY 27 & 28 SO THE
CLKIN2,	-34	/ EFFECTIVE RATE IS 550/27.5 = 20 TICKS/SEC
	>
/INTERRUPTS OTHER THAN 680 (LEVEL 1)
/DISMISSES TO LEVEL 2 IF NOT FROM LEVEL 1 OR 2.

INTAC,	0		/AC AT LEVEL 1
INTLK,	0		/LINK AT LEVEL 1
UUOA,	UUO0

	IFNZRO PTP1-3-.&4000	<GLITCH; *.-1>
	*PTP1-3
INT0,	DCA INTAC	/SAVE AC AND LINK
	RTR
	DCA INTLK
PTP1,
PINT,	PSF		/PUNCH?
	JMP CLKINT	/NO
	JMP I .+1	/YES
	PTPINT

CLKINT,
	IFZERO D680 <
		IFNZRO CPU-3 <
	CSCF		/SKIP AND CLEAR FLAG IF FLAG
		>
		IFZERO CPU-3 <
	CLSK		/SKIP IF IT'S THE 12 CLOCK.
		>
	JMP DTINT0
		IFZERO CPU-1 <
	CLA CMA		/RESET KW08 CLOCK
	CCF CLB		/CLEAR FLAG AND LOAD BUFFER
	CECI		/ & ENABLE
		>
		IFZERO CPU-3 <
	CLSA		/CLEAR THE CLOCK FLAG AND READ IN STATUS.
	CLA		/ THEN IGNORE THE STATUS
		>
		IFNZRO CPU-3 <
	ISZ CLKCNT	/IT WAS CLOCK - WAS IT A SYSTEM TIC?
	JMP CLKCHK	/NO - CHECK TO SEE IF WE'RE STILL UP
	TAD CLKINI	/YES - SET FOR NEXT SYSTEM TIC
	DCA CLKCNT
		>
	TAD L2TIMA	/SCHEDULE L2TIME ON L2QUE
	JMP DISMI0

	IFZERO CPU-2 <
CLKCNT,	-6	/NUMBER OF CLOCK TICKS/SYSTEM TICK = 6
CLKINI,	-6
	>
	IFNZRO CPU-2&4000 <
CLKCNT,	-3	/# OF CLOCK TICKS/SYSTEM TICK = 3
CLKINI,	-3
	>>

DTINT0,
	IFZERO TC01-1 <
	JMS DTCHK	/CHECK & DISPATCH IF DECTAPE
	>

RINT,	RSF		/READER?
	JMP DFINT	/NO
	JMP I .+1	/YES
	PTRINT

DFINT,
	IFZERO RF08-40 <
	DFSC		/DISC INTERRUPT?
	>
	IFZERO RF08 <
	DFSC DFSE	/DISC INTERRUPT?
	>
	JMP KINT	/NO
	DFSE		/SKIP ON NO ERROR (IF DF32)
	IFZERO RF08-40 <
	SKP
	>
	ISZ DSWAIT	/EXIT TO HANDLER+1 TO INDICATE ERROR
	JMP I DSWAIT
DSWAIT,	0		/SET BY DISC SERVICE

	IFZERO D680-2 <
KINT,	KSF		/KEYBOARD?
	JMP TINT	/NO
	KRB		/INPUT CHAR AND CLEAR FLAG
	TAD C1000
	DCA KCHAR
	JMP I KECHOA	/SCHEDULE ECHOING IF NECESSARY
TINT,	TSF		/TELEPRINTER?
	JMP I DFINTA	/CHECK DATA PHONES
	JMP I .+1	/YES
	TINT2
DFINTA,	DFINTD
KECHOA,	KECHO
	>

	IFZERO D680 <
		IFNZRO CPU-3 <
KINT,	TAD KDEV	/DEVICE CODE LIST-1
	JMS I INT21	/SEARCH LIST FOR INTERRUPT
	 TIDEV+NULINE+1
	JMP I KSERI	/FOUND - SERVICE THE KEYBOARD
TINT,	TAD TDEV	/SEARCH
	JMS I INT21
	 TODEV+NULINE+1
	JMP I TSERI	/SERVICE THE TELEPRINTER
	JMP I .+1	/CONTINUE IN THE INTERRUPT CHAIN
	DFINTD
		>

		IFZERO CPU-3 <
KINT,	JMS I	KDC21		/CHECK FOR TTY INPUT INTERUPT
	JMP I	KSERI		/YEP. IT'S THE ONE
TINT,	JMS I	TDC21		/CHECK FOR KEYBOARD INTERUPT
	JMP I	TSERI		/IT'S THE KEYBOARD. DO IT, BABY!
	REBOOT		/NEITHER - TIME TO RESTART

KDC21,	DC02K

JBDCY,	JMS I	JBDCSL
	TAD	DC02CH		/THE CHARACTER NOW.
	MTLS			/SEND OUT THE SELECTED CHARACTER
	JMP I	JBPTLS		/AND RETURN NOW

JBDCSL,	DC02SL
JBPTLS,	JBBTSL
TDC21,	DC02T
		>
	>
L2TIMA,	L2TIME
CLKIT,	0	/TEMPORARY FOR AC

	IFNZRO 262-.&4000 <
CLKCHK=	DISMI2
	>
	IFZERO 262-.&4000 <
CLKCHK,	LAS
	TAD OPCHK
	SNA CLA		/OPERATOR FORCED RESTART?
	REBOOT		/YES
	ISZ CLKMIS	/MISSED TOO MANY TICKS?
	JMP DISMI2
	REBOOT		/YES - RESTART THE SYSTEM
CLKMIS,	0
OPCHK,	-4321	/TOP SECRET RESTART CODE (SHH!)
	>
	IFZERO TC01-1 <
	IFNZRO DTINT-1-.&4000	<GLITCH; *.-1>
	*DTINT-1
/ROUTINE TO CHECK FOR A DECTAPE INTERRUPT.
/BY MAKING IT A SUBROUTINE, WE CAN CALL IT SEVERAL TIMES
/IN OUR INTERRUPT CHECKING, THEREBY MAKING IT HIGHLY
/UNLIKELY THAT WE WOULD MISS AN INTERRUPT & GET A 'TIM' ERROR.
DTCHK,	0
DTINT,	NOP		/DTSF WHEN DECTAPE IS RUNNING
	JMP I DTCHK	/NOT DECTAPE - JUST RETURN
	CIF DATFLD	/UP TO FIELD 1 DISPATCH
	JMP I .+1
	DTL11		/DECTAPE LEVEL 1 DISPATCH
	>
/DISMIS ROUTINE
/ENTERED FROM INTERRUPT HANDLER TO ENTER LEVEL 2 FROM LEVEL 1
/AC = ADDRESS OF LEVEL 2 SERVICE ROUTINE
/OR 0 IF NO LEVEL 2 SERVICE REQUIRED

	IFNZRO DISMI0-.&4000	<GLITCH; *.-1>
	*DISMI0
DISMI0,	SNA		/DISMIS INTERRUPTS
	JMP DISMI2	/NO-BACK TO WHATEVER WAS GOING ON BEFORE
	DCA CLKIT	/SAVE DISPATCH
	RIB		/MODE BIT = 100
	AND C0100
	SNA CLA		/FROM USER MODE?
	JMP DISMI1	/NO - QUEUE REQUEST UNTIL LATER
	TAD INTAC	/MOVE THE AC TO LEVEL 2
	DCA L2SA
	TAD INTLK	/MOVE LINK TO LEVEL 2
	DCA L2SVLK
	TAD 0		/MOVE PC TO LEVEL 2
	DCA L2SV0
	RIB
INT81,	DCA L2SF	/FIELDS AND MODE TO LEVEL 2
L2EXT1,	CLA CLL		/AC & LINK = 0 UPON ENTRANCE TO LEVEL-2 CODE
	CDF CIF		/DISMISS TO EXEC MODE, FIELD 0, LEVEL 2
	ION
	JMP I CLKIT

L2QPSH,	L2QUER	/PUSH ADDRESS ONTO L2QUE

/ROUTINE TO CAUSE AN EFFECTIVE SKIP BEFORE ENTERING UUOEXT.
UUOEX2,	ISZ L2SV0	/POSITIVE FLAG TEST EXIT
	NOP
/
/'UUOEXT' - EXIT ROUTINE FOR RESIDENT IOT HANDLERS.
/ENTERED WITH AC = WAIT-BITS TO CLEAR IN STR1 & SET IN WAIT-MASK 1
UUOEX1,	SNA		/ANY WAIT CONDITIONS?
	JMP UUOEX4	/NO - JUST CLEAN UP
	DCA WS0		/YES - SAVE BITS TO CLEAR
	TAD USKIOT
	SNA CLA		/WAS IT A NEGATIVE SKIP-TEST?
	JMP UUOEX3	/NO - SET THE WAIT-MASK
	DCA USKIOT	/YES - CLEAR OUR SKIP-TEST SWITCH
	JMS I IOLOOP	/IS IT COUPLED TO A 'JMP .-1'?
	JMP UUOEX4	/NO - THEN WE DON'T MAKE HIM WAIT
UUOEX3,	GETJTW		/YES - SET UP THE WAIT-MASK
	 JOBWMK
	CLA IAC
	TAD WS0		/WAIT ON THIS FLAG+JSWAIT
	DATFLD
	DCA I JOBSWA	/SET WAIT MASK 1
	ISZ JOBSWA
	DCA I JOBSWA	/CLEAR WAIT MASK 2
	TAD WS0		/BITS TO CLEAR
UUOEX4,	JMS I UUOWAT	/CHECK FOR WAIT
	TAD JOB
	RUNABL		/JOB STILL RUNABLE?
	WAIT		/NO - RESCHEDULE
			/YES - DROP THROUGH TO 'EXIT'

/LEVEL-2 EXIT ROUTINE.
/BEFORE DISMISSING BACK TO USER JOB, IT IS A GOOD IDEA TO
/CHECK AND SEE IF ANY OTHER LEVEL-2 PROCESSING HAS BEEN
/SCHEDULED WHILE WE WERE WORKING ON THE LAST REQUEST.
/WE CAN ASCERTAIN IF THIS IS THE CASE BY COMPARING THE
/LEVEL-2 (L2QUE) EMPTY AND FILL POINTERS; IF THEY ARE
/EQUAL, THEN WE'RE DONE AND CAN GO TO L2EX1, WHERE BOTH
/POINTERS ARE RESET. IF THEY ARE UNEQUAL, WE GET THE NEXT
/QUEUE ENTRY & DISPATCH TO IT.

L2EXIT,	CDF
	IOF		/NO INTERRUPTS WHILE CHECKING L2QUE STATUS
	TAD L2Q
	CIA
	TAD L2QE	/-FILL PTR + EMPTY PTR
	SNA CLA		/ARE FILL & EMPTY POINTERS EQUAL?
	JMP I L2EX1A	/YES - WE ARE CAUGHT UP
	TAD I L2QE	/NO; GET ADDRESS FROM L2QUE
	DCA CLKIT
	JMP L2EXT1	/GO CLEAR AC & LINK AND DISPATCH

IOLOOP,	IOWAIT
L2EX1A,	L2EX1
USKIOT,	0
UUOWAT,	DEVWAT

DISMI1,	TAD CLKIT
	JMS I L2QPSH	/QUEUE REQUEST AND CHECK FOR OVERFLOW
DISMI2,	TAD INTLK	/RESTORE LINK AND AC
	CLL RTL
	TAD INTAC
	RMF		/RESTORE IF, DF & MODE
	ION
	JMP I 0		/BACK TO INTERRUPTED PROGRAM
	IFNZRO GIRSC-.&4000	<GLITCH; *.-1>
	*GIRSC
/STORE  CHARACTER
/CALL WITH ADDRESS OF DDB IN AC, CHARACTER IN TTCHAR
/	STORE
/	WON'T FIT
/	OK

GIRSC,	0
	TAD DBINPA
	DCA GIRSB	/POINTS TO ADDRESS OF BUFFER (FILL-POINTER)
	RDF		/FIGURE OUT WHERE WE CAME FROM...
	TAD C6203	/AND SET UP EXIT BACK THERE
	DCA GIRFLD
	DATFLD
	TAD GIRSB	/ADDRESS OF WORD 5 OF DDB
	IAC
	DCA GIRSCT	/ADDRESS OF FILL COUNT IN DDB
	TAD I GIRSB
	SNA CLA		/IS BUFFER SET UP? (I.E. IS FILL POINTER NON-ZERO?)
	JMP GIRSC8	/NO-GO GET A BUFFER
	ISZ I GIRSCT	/ANY ROOM LEFT?
	JMP GIRSC4	/YES
	TAD GIRSB	/CAN WE GET ANOTHER BUFFER
	TAD C0002
	JMS I GRBUFS	/TEST TO SEE IF HE ALREADY HAS "MAXBUF" BUFFERS
	 -MAXBUF
	JMP GIRSC2	/NO - GIVE HIM ANOTHER
	TAD SOURCE
	TAD M177
	SNA CLA		/IS THIS 'SI' TYPING?
	JMP GIRSC1	/YES
	TAD SOURCE
	AND C0100
	SZA CLA		/NO - IS IT A PROGRAM TYPING?
	JMP GIRSCX	/YES - NO MORE BUFFERS
	TAD GRPROG	/NO - SET LIMIT FOR KEYBOARD
GIRSC1,	TAD GRSI	/ OR FOR 'SI'
	DCA GIRST
	CLA CLL CML RTL
	TAD GIRSB
	JMS I GRBUFS	/HAS HE REACHED HIS ABSOLUTE LIMIT?
GIRST,	 0
	SKP		/NO - SET FLAG FOR 'XOFF' & GIVE HIM ANOTHER
	JMP GIRSCX	/YES - NO MORE BUFFERS; MAYBE RING BELLS NOW
	CDF
	TAD I GIRDB1	/GET THE INPUT DDB ADDRESS FROM 'GIR'
	DATFLD
	SNA		/IS IT ZERO?
	JMP GIRSC2	/YES - WE MUST BE COMING FROM 'SI'
	IOR		/SET THE FLAGS TO SEND AN 'XOFF'
	 DXON+DXOUT
GIRSC2,	CLL CLA CMA RAL	/IS THERE ENOUGH (I.E. 2 BLOCKS) OF FREE CORE LEFT?
	TAD FRECNT
	SPA SNA CLA
	JMP GIRSCX	/NO-DON'T GIVE HIM ANOTHER BUFFER NOW
	TAD I GIRSB	/OK-GET A BUFFER
	CDF
	GETBLK		/NO. LINK NEW BUFFER
	JMP GIRSCX	/NONE AVAILABLE
	DATFLD
	TAD I GIRSB	/POINTER TO HEAD OF NEW BUFFER
	DCA GIRST
	TAD I GIRST
	DCA I GIRSB	/BUFFERS NOW CHAINED TOGETHER
GIRSC3,	TAD GIRSIZ	/INITIALIZE CHAR COUNT TO -12
	DCA I GIRSCT	/AND SAVE IN DDB
GIRSC4,	TAD I GIRSCT	/ARE WE DOING LAST THREE CHARACTERS IN BLOCK
	TAD C0003
	SMA
	JMP GIRSC6	/YES-THEY ARE SPLIT UP IN LEFTMOST 4 BITS OF BUFFER
	CIA		/NO-GET ADDRESS WITHIN BUFFER
	TAD I GIRSB	/START OF BUFFER
	DCA GIRSB	/ADDRESS TO STORE CHARACTER
	TAD TTCHAR
	DCA I GIRSB	/STORE CHARACTER
GIRSC5,	ISZ GIRSC	/INDICATE SUCCESS
GIRFLD,	0		/RETURN TO CALLING FIELD
	CLA CLL
	JMP I GIRSC
GIRSC6,	CLL RAL		/LAST 3 CHARS REQUIRE SPECIAL TREATMENT
	TAD I GIRSB	/(CHARACTER COUNT-3)*2+1 IS ADDRESS IN BUFFER FOR HALF CHAR.
	DCA GIRSB	/ADDRESS IN BUFFER
	CLA CLL CMA RTL	/AC = -2
	DCA GIRSCT
	TAD TTCHAR
GIRSC7,	CLL RTL; RTL
	DCA GIRST
	ISZ GIRSB	/GET TO THE PROPER BUFFER-WORD
	TAD I GIRSB
	AND C0377	/SAVE CHARACTER ALREADY IN LOW ORDER 8 BITS
	DCA I GIRSB
	TAD GIRST	/NOW GET HIGH ORDER 4 BITS
	AND C7400
	TAD I GIRSB	/AND SAVE IN CURRENT LOCATION IN BUFFER
	DCA I GIRSB
	TAD GIRST	/GET BACK THE CHARACTER (SHIFTED)
	ISZ GIRSCT	/HAVE WE DONE BOTH HALVES?
	JMP GIRSC7	/NO - DO SECOND HALF
	JMP GIRSC5	/YES - RETURN

GIRSC8,	CDF		/ATTACH A BUFFER TO FILL POINTER
	TAD GIRSB	/LINK ADDRESS
	GETBLK
	JMP GIRFLD	/CAN'T GET ONE - TOO BAD
	DATFLD		/OK - SET UP POINTERS
	TAD GIRSCT	/ADDRESS OF FILL COUNT
	IAC		/+1 ..
	DCA GIRST	/ ADDRESS OF EMPTY POINTER
	TAD I GIRSB	/SET EMPTY POINTER EQUAL TO FILL POINTER
	DCA I GIRST	/SINCE ITS THE ONLY BUFFER
	ISZ GIRST	/NOW INITIALIZE THE EMPTY COUNT
	TAD GIRSIZ	/TO -12
	DCA I GIRST	/ IN THE DDB
	JMP GIRSC3

GIRSCX,	DATFLD		/COULDN'T SQUEEZE CHARACTER IN
	STA		/BUT WE ALREADY BUMPED FILL COUNT
	TAD I GIRSCT	/SO NOW WE UNBUMP IT
	DCA I GIRSCT
	JMP GIRFLD	/AND EXIT WITHOUT SKIPPING

	IFNZRO DDBINP-4	<GLITCH; *.-1>
DBINPA=	C0004	/DDBINP
GIRDB1,	GIRDBA
GIRSB,	0
GIRSCT,	0
GIRSIZ,	-12	/10 (DECIMAL) CHARACTERS/BLOCK
GRBUFS,	BUFSIZ
GRPROG,	-MAXBUF-1+MAXBUF+MAXBUF
GRSI,	-MAXBUF-MAXBUF	/SI GETS TWICE NORMAL BUFFER SPACE
M177,	-177

	IFNZRO OVRLA1-.&4000	<GLITCH; *.-1>
	*OVRLA1
/
/DISC COMPLETION DISPATCHER FOR SYSTEMIC OVERLAYS.
OVRLA1,	JMS I FIUSER
	WAIT
	PAGE

/RETURN TTY BUFFER TO FREE LIST
/CALL	TAD BUFFER ADDRESS
/	RETBLK
/	RETURN WITH LINK IN AC

RETB,	0
	SNA		/LEGAL RELEASE?
	REBOOT		/NO - ERROR *****
	DCA RETB1	/SAVE BLOCK ADDRESS
	RDF
	TAD C6203
	DCA RETF	/FOR RETURNING TO CALLER
	TAD RETB1
	TAD RETFIP
	SNA CLA		/IS THIS THE 'FIP' I/O BLOCK?
	JMP RETF	/YES - IT DOESN'T GET RELEASED
	DATFLD
	TAD I RETB1	/NO - GET THE LINK FROM THE BLOCK
	DCA RETBL
	TAD FREE	/GET OLD START OF FREE LIST
	DCA I RETB1	/PUT IT IN LINK
	TAD RETB1	/PUT ADDRESS OF THIS BLOCK
	DCA FREE	/ AS START OF FREE LIST
	ISZ FRECNT	/INCREMENT THE FREE-COUNT
	TAD RETBL
RETF,	0		/RETURN WITH LINK
	JMP I RETB

RETFIP,	-FIPBLK
SJIOTC,	JSIOTC

/START USER JOB

SUJ,	TAD L2SF	/CLEAR NOTRUN FLAG SO JOB CAN BE SWAPPED
	AND C0007	/GET CORTBL INDEX
	TAD CORTBA
	DCA SUJSRC	/POINTS TO ENTRY IN CORTBL FOR THIS JOB
	TAD I SUJSRC	/GET CORTBL ENTRY
	AND CNOTR	/CLEAR NOT RUN BIT
	DCA I SUJSRC	/SAVE ENTRY
	TAD JOB
	AND C0600
	SZA CLA		/IS THIS A PHANTOM?
	EXIT		/YES - WE'RE ALL SET
	JMS I SUJUDF	/SET UUDF
	GETJTW		/NO. IOT RESULTS TO USER?
	 JOBSTS
	DATFLD
	AND SJIOTC	/IOTC BIT IN STR0
	SNA
	JMP SUJ4	/NO - WAS THERE A SYSTEM ERROR?
	CMA		/CLEAR THE BIT
	AND I JOBSWA	/JSIOTC:=0
	DCA I JOBSWA	/SAVE NEW STR0
	GETJTW		/GET # ARGUMENTS TO RETURN
	 JOBLNK
	DCA SUJSRC	/POINTS TO WORD 1 OF PARAMETER BLOCK
	TAD L2SVLK	/GET THE LINK SAVE-WORD
	CLL RTR
	RTR
	RAR
	AND C0007	/GET THE PARM COPY-COUNT
	SNA		/IS IT A ZERO?
	JMP SUJ3	/YES - JUST BACK FROM WINDOW-TURN
	CIA
	DCA SUJCNT	/SAVE COUNT
	TAD L2SA
	DCA SUJDES	/SET THE USER'S PACKET ADDRESS
	DATFLD
	TAD I SUJSRC	/THEN GET THE VALUE
	DCA L2SA	/ TO RETURN IN HIS AC
	ISZ SUJSRC	/POINTS TO WORD 2 OF BLOCK
	TAD UUDF	/TRANSFER RESULTS TO USER'S FIELD
	DCA SUJDFS
	CDF
	BLT		/MOVE RESULTS TO USER
	 DATFLD		/FROM FIELD 1
SUJSRC,	 0		/SOURCE ADDRESS
RETBL,
SUJDFS,	 0		/TO USER FIELD
RETB1,
SUJDES,	 0		/AT THIS ADDRESS
SUJCNT,	 0		/-WORD COUNT
	CLA CMA
	TAD SUJSRC	/GET THE BLOCK ADDRESS
	RETBLK		/ AND RELEASE THE BLOCK
CM200,	-200		/ (ALSO ACTS AS 'CLA')
	EXIT		/OFF TO USER PROGRAM

SUJ3,	GETJTW		/COMING BACK FROM WINDOW TURN; WAIT ON FILE STUFF
	 JOBSTS+1
	AND C7776
	DATFLD
	DCA I JOBSWA	/CLEAR THE DUMMY WAIT BIT IN STR1
	TAD SUJSRC	/UFILE RETURN
	JMP I .+1
	SIFILE

SUJ4,	TAD I JOBSWA	/GET STR0
	AND SUJERR
	SNA CLA		/SYSTEM ERROR?
	EXIT		/NO - OFF TO USER JOB
/
/THE USER HAS AN ERROR CODE SET. SINCE WE GOT HERE, HE
/MUST BE ENABLED TO HANDLE IT; WE DO AN EFFECTIVE
/'JMS' TO HIS ERROR-HANDLING ROUTINE.
	GETJTW		/GET HIS ERROR-ADDRESS
	 JOBERR
	DCA WS0		/POINTS TO HIS ROUTINE
	TAD L2SV0
	UDF
	DCA I WS0	/SAVE THE ERROR-ADDRESS IN HIS ROUTINE
	TAD WS0
	IAC
	DCA L2SV0	/ AND SET THE NEXT LOCATION AS HIS PC
	EXIT		/THEN JUST EXIT

SUJERR=	C0007
SUJUDF,	UDFSET
/IF THE USER EXECUTES A FLAG TEST IOT (EG KSF, TSF, ETC.)
/THEN IT IS USEFUL TO KNOW IF HE IS IN A "WAIT LOOP"
/(I.E. KSF; JMP .-1) OR IF HE IS JUST CHECKING TO SEE
/IF THERE IS ANYTHING WORTH LOOKING AT.  IN THE FORMER
/CASE, WE WILL DISMIS THE USER UNTIL THE FLAG TEST IS
/SATISFIED; IN THE LATTER, THE USER IS ALLOWED TO
/PROCEED, REGARDLESS OF THIS FLAG'S STATUS.
IOWAIT,	0		/DETERMINE IF USER'S INSTRUCTION IS JMP .-1
	UDF		/SELECT USER'S FIELD
	TAD I L2SV0	/GET INSTRUCTION FOLLOWING SKIP IOT
	CIA
	DCA JOBSWA	/-INSTRUCTION
	STA
	TAD L2SV0	/COMPUTE .-1
	AND CP0177	/SAVE LOW ORDER 7 BITS
	TAD C5200	/JMP DIRECT CURRENT PAGE
	TAD JOBSWA	/USER'S INSTRUCTION
	SNA		/JMP .-1 ON CURRENT PAGE?
	JMP IOWAT2	/YES
	TAD CM200
	SZA CLA		/NO - PAGE 0?
	JMP IOWAT1	/NO-- NOT A JMP .-1
	CLA CMA
	TAD L2SV0	/ADDRESS OF USER INSTRUCTION
	TAD CM200
	SPA CLA		/WOULD A JMP .-1 LAND ON PAGE 0?
IOWAT2,	ISZ IOWAIT	/YES - INCREMENT RETURN FOR JMP .-1
IOWAT1,	JMP I IOWAIT

CP0177,	177
C5200,	5200
	PAGE

/PAPER TAPE READER SERVICE FOR TSS/8
UPTR,	6212	/FIELD ONE ROUTINE
	JMS I	PTRCHK		/DOES HE OWN DEVICE
PTRDEV,	DEVTBE			/POINTS TO READER ENTRY IN DEVTBL
	JMS	PTRINI		/GO INITIALIZE IT

	JMS I	PTRIOT		/ANALYZE IOT
	JMP	URRS		/READ A STRING
PTRFL,	JSPTR			/READER FLAG
	JMP	UPRWX		/FLAG TEST AND EMPTY BUFFER
	SNL			/RRB?
	JMP	URFC		/NO - CHECK RFC

URRB,	DCA	UUOCAL		/SAVE RFC INDICATOR
	TAD	PTRCNT		/ANYTHING IN BUFFER
	SNA CLA
	JMP	UPRDUM		/NOTHING IN BUF - LEAVE L2SA ALONE
	DATFLD			/SOMETHING THERE
	TAD I	PTREMP		/PICK UP CHAR
	CDF
	DCA	PTRCH
	TAD	PTRACA		/POINTS TO L2SA
	IOR		/OR CHARACTER INTO L2SA
PTRCH,	 0
	ISZ	PTREMP		/BUMP EMPTY PTR
	ISZ	PTRCNT		/BUMP CHARACTER COUNT
PTRNOP,	NOP			/DON'T CARE IF COUNT GOES TO 0
UPRDUM,	TAD	UUOCAL		/RESTORE RFC INDICATOR

URFC,	SNA CLA			/EVENT TIME 4?
	JMP	UPRX		/NO - EXIT TO USER
	JMS	PTRGO		/ANYTHING IN BUFFER?
	JMP UPFLEX		/YES- GO SET HIS READER FLAG
UPRWX,	TAD	PTRFL		/NO - HAD TO START READER
UPRX,	UUOEXT			/EXIT TO USER

UPFLEX,	CLL CML		/LINK = 1 FOR UUOEXT DEPARTURE
	JMP UPFLX1
PTRINI,	0			/INITIALIZE READER
	DCA	PTRCNT		/CHAR COUNT=0
	TAD	PTRBFA
	DCA	PTRFIL		/FILL POINTER=START OF BUFFER
	JMP I	PTRINI
/ROUTINE TO START READER IF BUFFERS EMPTY
/CALLING SEQUENCE=
/	JMS	PTRGO
/	RETURN IF CHAR IN READER BUFFER
/	RETURN IF READER JUST STARTED

PTRGO,	0
	TAD	PTRCNT		/ANYTHING IN BUFFER
	SZA CLA
	JMP I	PTRGO		/YES - RETURN
	DATFLD			/NO - ARE WE OUT OF TAPE?
	TAD I	PTRDEV		/POINTS TO UNIT # IN DDB
	DCA	WS0		/POINTS TO FLAGS + JOB# IN DDB
	TAD I WS0		/SEE IF IT'S OUT OF TAPE
	CDF
	RTL
	SPA CLA
	JMP I	UPHANG		/YES - THIS HANGS READER
	JMS	PTRINI		/INITIALIZE POINTERS
	TAD PTRGO1	/PICK UP ADDRESS OF PARAMETER
	JMS I PTRTIM		/START TIMER IN SCHED
	RFC			/START READER GOING.
	ISZ	PTRGO		/INDEX RETURN
	JMP I	PTRGO		/RETURN

UPHANG,	UPHANA		/INDICATE HUNG DEVICE
URRS,	UDF			/READ A STRING
	TAD I	L2SA		/-# CHARS TO READ
	CDF
	SNA CLA
	JMP	PTRUCK+2		/ALL DONE

UPTRST,	JMS	PTRGO		/ANYTHING IN BUFFER
	JMP	PTREDY		/YES
	STA			/BACK UP USER PC AND WAIT
	TAD L2SV0
	DCA L2SV0
	JMP UPRWX

PTREDY,	UDF			/SELECT USER FIELD
	TAD	L2SA		/POINTS TO -# CHARS
	IAC
	DCA	WS0		/POINTS TO ADD-1 IN USER FIELD
	TAD I	WS0
	DCA	AXS1
PTRANS,	DATFLD
	TAD I	PTREMP		/GET CHAR FROM BUFFER
	ISZ PTREMP		/BUMP POINTER
	UDF
	DCA I	AXS1		/STORE IN USER AREA
	ISZ	PTRCNT		/ANYTHING STILL IN BUFFER
	JMP	PTRUCK		/YES
	TAD	AXS1		/NO - SET UP USER PARAMETERS FOR REDO
	DCA I	WS0
	ISZ I L2SA
	NOP
	CDF
	JMP	UPTRST		/GO RESTART READER

PTRUCK,	ISZ I	L2SA		/GOTTEN WHAT HE ASKED FOR?
	JMP	PTRANS		/NO - GIVE HIM ANOTHER CHARACTER
	DCA	L2SA		/YES - SET USER AC=0
	JMP	UPRX		/EXIT - NO WAIT

PTRIOT,	UKT1
PTRCNT,	0
PTREMP,
PTRFIL,	0
PTRACA,	L2SA
PTREND,	-PTRBUF-PTRSIZ+1
PTRBFA,	PTRBUF
PTRTIM,	PTTIM
/READER INTERUPT SERVICE
PTRINT,	RRB			/READ CHAR AND CLEAR FLAG
	DATFLD
	DCA I	PTRFIL		/DUMP CHARACTER IN BUFFER
	CDF
	STA
	TAD	PTRCNT		/PTRCNT=PTRCNT-1
	DCA	PTRCNT
	TAD	PTRFIL
	TAD	PTREND
	SMA CLA		/STILL ROOM IN THE BUFFER?
	JMP	RINT1		/NO - START THE USER JOB
	ISZ	PTRFIL		/YES - BUMP FILL PTR
	RFC			/GET ANOTHER CHARACTER
	DISMIS

RINT1,	TAD	.+2		/SCHEDULE LEVEL 2 SERVICE
	DISMIS
	PTRL2
PTRL2,	TAD	PTRBFA		/SET EMPTY PTR TO START OF BUFFER
	DCA	PTREMP
	TAD	PTRNOP		/KILL PAPER TAPE TIMER IN SCHED
	DCA I	PTRSKP
	CLL		/LINK = 0 FOR RETURN THROUGH 'EXIT'
UPFLX1,	TAD	PTRFL		/GO TURN ON READER BIT AND EXIT
	JMS I	PTSTRT
	DEVTBE

PTSTRT,	PTSTAR

PTRGO1,	.+1
PTRSKP,	PTRSKA
	PTRISZ
	TIPTR1
	PAGE
	IFNZRO .-1200	<GLITCH; *.-1>	/GIR ASSUMES THIS AT 1200
SWKBD,	0
	TAD SOURCE
	AND C0100	/PROGRAM OR CONSOLE?
	SNA CLA
	JMP SWKIN	/CONSOLE
	TAD SOURCE
	TTYUSE		/GET OUTPUT DDB ADDRESS
	 1		/ (OUTPUT SIDE)
	STORE		/PUT CHARACTER IN BUFFER
	JMP I SWKBD	/BAD
SWKEXT,	ISZ SWKBD	/GOOD
	JMP I SWKBD
SWKIN,	TAD SOURCE	/GET CONSOLE #
	AND C0037
	CLL RAL
	TAD DEVTBA	/COMPUTE POSITION IN DEVTBL
	DCA SWIDVA
	TAD I SWIDVA	/ADDRESS OF DDB
	DCA SWIDDB
	CDF
	TAD SWIDDB
	STORE		/CHARACTER TO INPUT BUFFER
	JMP SWIKFL	/DOESN'T FIT
	DATFLD		/DUPLEX MODE?
	TAD I SWIDDB
	AND C0200
	SNA CLA
	JMP SWKIN1	/NO
	ISZ SWIDVA	/YES- GET PTR TO OUTPUT SIDE
	TAD I SWIDVA	/ADDRESS OF OUTPUT DDB
	CDF
	STORE		/CHARACTER TO OUTPUT BUFFER
	NOP
SWKIN1,	DATFLD		/BREAK CHARACTER?
	TAD SWIDDB
	TAD C0002
	DCA SWITMP	/POINTS TO BREAK MASK
	TAD I SWITMP	/BREAK MASK
	CIF DATFLD
	BREAK
	JMS SWKDLM	/YES-SET DELIMITER FLAG
	JMP SWKEXT	/NO

SWIDVA,
SWITMP,
SWKDLM,	0		/ROUTINE TO SET DELIMITER FLAG IN STR1
	TAD SWIDDB
	JMS I SWIJOB	/GET JOB #
	TAD JOBTBA
	GETJTA		/GET POINTER TO STR1
	 JOBSTS+1
	DATFLD
	IOR		/OR IN DELIMITER BIT (& AWAKEN HIM)
	 JSDEL+JSTIME
	JMP I SWKDLM	/AND BACK

SWIKFL,	JMS SWKDLM
	JMP I SWKBD	/TAKE ERROR EXIT

SWIJOB,	DELBON

/ROUTINE TO HANDLE EASY DECTAPE STUFF
/LIKE DTSF AND DTRB
/DTSF ALWAYS SKIPS

	IFZERO TC01-1 <
UDTRBS,	ISZ L2SV0	/BUMP HIS PC
	NOP		/TRICKY, TRICKY
UDTRB,	GETJTW		/GET LAST VALUE OF STATUS B
	 JOBSTB
	DCA L2SA	/GIVE IT TO USER
	UUOEXT		/AND BACK
	>

DFINTD,
	IFZERO D689-4 <
	CIF DATFLD	/DISPATCH TO FIELD ONE
	JMP I .+1	/AND CHECK TO SEE IF PHONES ARE RINGING
	DFINT1
	>
	IFZERO D689 <
	JMP I .+1
	INTCOM
	>
/SEARCH FOR JOB IN CORE
/CALL	TAD JOB #
/	CORE
/	 MASK
/	NOT THERE, AC:=0
/	THERE, SAVE FIELD IN AC


/THESE TWO WORDS MUST IMMEDIATELY PRECEDE CORSRC
/THEY MUST ALSO BE ORIGINED AT CORSRC-2 OR NOTHING WILL WORK
/THAT'S TWICE IT GOT ME

	IFNZRO CORSRC-2-.&4000	<GLITCH; *.-1>
	*CORSRC-2

CORCNT,	0	/INIT TO (-) THE NUMBER OF USER FIELDS
CORTBE,	0	/INIT TO (-) THE FIRST LOCKED 'CORTBL' ENTRY

CORSRC,	0		/ENTER WITH BIT PATTERN TO MATCH
	AND I CORSRC	/MASK AS SPECIFIED
	CIA
	DCA CORSR4	/-WHAT WE WANT
	RDF		/FIGURE OUT WHENCE WE CAME
	TAD C6203
	DCA CORSR3	/SO WE CAN RETURN
	TAD I CORSRC	/GET THE MASK
	DCA CORSR2	/SAVE IT
	ISZ CORSRC	/SKIP PAST MASK IN CALL
	CDF
	TAD CORCNT	/-# ENTRIES TO CHECK
	DCA AXS1	/USED AS COUNTER
CORSR1,	ISZ CORTBP	/INCREMENT TABLE POINTER
	TAD CORTBP
	TAD CORTBE
	SZA CLA		/ARE WE PAST THE END OF 'CORTBL'?
	JMP CORSR5	/NO
	TAD FANCOR
	DCA CORTBP	/YES - REINITIALIZE THE POINTER
CORSR5,	TAD I CORTBP	/GET TABLE ENTRY
	AND CORSR2	/MASK IT
	TAD CORSR4	/COMPARE WITH DESIRED ENTRY
	SNA CLA
	JMP CORSR6	/FOUND IT!
	ISZ AXS1	/NOT YET
	JMP CORSR1	/KEEP GOING
SWIDDB,
CORSR3,	0		/RETURN WITH AC=0
	JMP I CORSRC
CORSR6,	TAD CORTBA	/WE HAVE IT; GET CORTBL INDEX
	CIA
	TAD CORTBP
	DCA AXS1	/FIELD #
	TAD CORSR4	/WE HAVE TO SET MODE BIT APPROPRIATELY
	CIA		/RECOMPLEMENT CALLING JOB #
	AND C0600	/A PHANTOM?
	SNA CLA		/EXEC MODE?
	TAD COR10	/NO - SET USER MODE BIT
	TAD AXS1	/SET UP SAVE FIELD
	CLL RTL		/SHIFT AND ADD DATA FIELD
	RAL
	TAD AXS1
	ISZ CORSRC	/SKIP TO INDICATE SUCCESS
	JMP CORSR3	/BACK
CORSR2,	0
CORSR4,	0
CORTBP,	CORTBL	/PERMANENT "ROUND-ROBIN" POINTER
COR10,	10
/ROUTINE TO SEE IF DSI IS SET IN DDB
/THIS ROUTINE IS USED IN ORDER TO PREVENT
/THE ^B'S TYPED BY USER FROM RESTARTING
/AN OUTPUT BOUND PROGRAM.
/OTHERWISE THE ^B'S WOUD CLEAR THE OUTPUT BUFFER
/AND SET THE FLAG; THE PROGRAM WOULD THEN
/BE RUNABLE AND THE TTY WOULD FROTH AT THE
/MOUTH.  THE POOR USER WOULDN'T KNOW WHAT
/TO DO!
/PRETTY MESSY, WASN'T IT!

/CALLING SEQUENCE
/	TAD (DDB ADDRESS FOR THIS DEVICE)
/	DATFLD
/	JMS CONCB
/	RETURN IF CONSOLE IN SI MODE
/	RETURN IF CONSOLE IN USER MODE

CONCB,	0
	DCA CONCB1
	TAD I CONCB1	/WORD 0 OF DDB
	AND CONDSI
	SNA CLA
	ISZ CONCB	/NOT GOING TO SI-INDEX RETURN
	JMP I CONCB

	IFNZRO DSI-1000	<GLITCH; *.-1>
CONDSI=	C1000	/DSI
CONCB1,	0

	IFZERO TC01-1 <
UDTXA0,	CIF DATFLD		/FIELD 1 DTA UUO SERVICE
	JMP I .+1
	UDTXA
	>
	PAGE

/GET A BUFFER FROM FREE LIST
/CALL	TAD (ADDRESS TO STORE LINK)
/	GETBLK
/	NONE AVAILABLE
/	OK WITH LINK STORED

CLST0,
GETDB2,
GETB,	0
	DCA GETBT	/SAVE ADDRESS TO SAVE PTR
	RDF		/SAVE CALLING FIELD
	TAD C6203
	DCA GETB2	/SO WE CAN GET BACK
	DATFLD
	CLA CMA
	TAD FRECNT
	SPA		/ANY BLOCKS LEFT?
	JMP GETB1	/NO - TAKE ERROR RETURN
	DCA FRECNT	/YES - SAVE THE NEW COUNT
	TAD FREE
	DCA I GETBT	/STORE LINK IN ADDRESS SPECIFIED
	TAD FRECNT
	SNA CLA		/IS THIS THE END?
	JMP .+5		/YES (WE SHOULD REALLY ZERO 'FREE')
	TAD I FREE	/NO - GET THE FORWARD LINK
	SNA		/ZERO?
	REBOOT		/YES - ERROR *****
	DCA FREE	/NO - SET NEW FREE-LIST START
	ISZ GETB	/ AND INDICATE SUCCESS
	STA		/NOW WE'LL BE GOOD GUYS
	TAD I GETBT	/ AND CLEAR THE BUFFER
	DCA AXS1
	TAD C7770	/8 WORDS TO ZERO
	DCA GETBT
	DCA I AXS1
	ISZ GETBT	/DONE?
	JMP .-2		/NO
GETB1,	CLA CLL
GETB2,	0		/YES - RESET THE FIELD
	JMP I GETB	/ AND RETURN

/ROUTINE TO HANDLE THE 'STM' IOT - WE MERELY MAKE
/AN ENTRY IN CLKTBL FOR THIS JOB.
USTM,	TAD L2SA	/GET UNITS OF TIME IN AC
	DCA WS0		/SAVE IT
	DCA L2SA	/ZERO USER'S AC
	TAD WS0
	CIA		/- # OF UNITS OF TIME
	SNA		/ANY TIME SPECIFIED?
	WAIT		/NO - TREAT LIKE 'SYN' IOT
	JMP I .+1	/YES, GO PUT TO SLEEP
	DOUSTM
/GET A DATA BLOCK
/CALL	TAD LINK
/	GETDDB
/	NONE AVAILABLE
/	OK

	IFNZRO DDBTIM-3	<GLITCH; *.-1>
GETTIM=	C0003	/DDBTIM

DEVWT0,
GETDB0,	0
	DCA GETDB1	/ADDRESS OF DDB POINTER (USUALLY IN DEVTBL)
	RDF
	TAD C6203
	DCA GETDB5	/SAVE CALLING FIELD SO WE CAN GET OUT
	CDF
	TAD GETDB1
	GETBLK		/GET A BUFFER FROM FREE-CORE
	JMP GETDB5	/BOO! HISS! THEY'RE FRESH OUT
	DATFLD
	ISZ GETDB0	/SUCCESSFUL RETURN
	TAD I GETDB1
	DCA GETDB1	/DDB ADDRESS
	TAD SOURCE	/UNIT # SAVED IN WORD 1 OF DDB
	DCA I GETDB1
	TAD GETDB1
	TAD GETTIM
	DCA GETDB1	/SET POINTER TO ASSIGN-TIME
	TAD CLK1	/GET LOW ORDER CLOCK
	RTL		/AND SHIFT BITS 0-2 INTO AC 9-11
	RTL
	AND C0007	/GET MOST SIGNIFCANT BITS FROM LOW ORDER
	DCA GETDB2	/SAVE THEM
	TAD CLK2	/GET HIGH ORDER TIME
	RTL		/SHIFT LEFT 3 PLACES
	RAL
	AND C7770	/KEEP BITS 0-8
	TAD GETDB2	/ADD COMPONENT DERIVED FROM CLK1
	DCA I GETDB1	/SAVE IN DDB
GETDB5,	0		/RETURN
	JMP I GETDB0
/AFTER EXECUTING AN IOT FOR A USER PROGRAM,
/UUOEXT IS CALLED WITH THE AC BITS SET TO
/INDICATE WHICH STATUS BITS (IF ANY)
/HAVE BEEN CHANGED (I.E. CLEARED).
/
/THIS ROUTINE DOES THE ACTUAL CLEARING OF BITS
/IF ANY BITS ARE CLEARED, INDICATING A WAIT CONDITION,
/THEN THE DUMMY WAIT BIT (BIT 11 OF STR1) IS ALSO
/CLEARED

/CALL:	TAD <WAIT-BIT>
/	JMS DEVWAT
/	RETURN

GETBT,
DEVWAT,	0
	DCA DEVWT0	/STR1 BITS TO CLEAR
	TAD DEVWT0
	IAC		/CLEAR JSWAIT ALSO
	JMS CLSTR1
	TAD DEVWT0	/DID WE CLEAR ANYTHING
	DATFLD
	SNA CLA
	ISZ I JOBSWA	/NO, TURN JSWAIT BACK ON
	CDF
	JMP I DEVWAT	/GO AWAY

GETDB1,
CLSTR1,	0		/ROUTINE TO CLEAR BITS IN STR1
	CMA		/ENTER WITH BITS TO CLEAR IN AC
	DCA CLST0	/SAVE MASK OF BITS TO SAVE
	GETJTW		/GET CURRENT SETTING OF STR1
	 JOBSTS+1
	AND CLST0	/CLEAR SELECTED BITS
	DATFLD
	DCA I JOBSWA	/SAVE CLEARED STATUS REGISTER
	CDF
	JMP I CLSTR1	/RETURN
/WHEN THE USER EXECUTES A "SEA" IOT,
/WE MUST DO TWO THINGS:
/	1) SET THE ERROR ENABLE BIT IN STR0
/	2) SAVE THE USER'S AC IN THE JOB DATA AREA
/	   JSEREN IS SET HERE
/	WE GO TO USEA1 TO SAVE THE ERROR ADDRESS
/JSEREN MAY BE CLEARED BY .RUN, START, OR
/A USER EXECUTING A "CLEAR STATUS" IOT.

USEA,	DATFLD		/SET JSEREN WHEN USER EXECUTES SEA
	TAD I CJOBDA	/POINTS TO WORD 0 OF JOB DATA AREA
	IAC		/POINTS TO STR0
	IOR		/OR IN JSEREN
	 JSEREN
	CLA CLL CMA RAL	/AC = -2, TO GET JOB DATA POINTER

/ROUTINE TO SET SWITCH REGISTER, RESTART ADDR., OR ERROR
/ADDR.  THIS ROUTINE IS VERY SENSITIVE TO THE POSITION
/OF THESE CELLS IN THE JOB DATA AREA.  USE CAUTION.

	IFNZRO JOBSRA-5	<GLITCH; *.-1>
	IFNZRO JOBERR-6	<GLITCH; *.-1>
	IFNZRO JOBSWR-10<GLITCH; *.-1>
USSW,	TAD C0003	/AC = 3 (SWITCH REGISTER)
USRA,	TAD K0005	/AC = AC+5 (RESTART ADDRESS)
	DCA .+2
	GETJTW		/GET THE APPROPRIATE POINTER
	 0
	CLA
	TAD L2SA	/GET THE PASSED PARAMETER
	DATFLD
UKSB1,	DCA I JOBSWA	/ AND SAVE IN THE JOB DATA AREA
	DCA L2SA	/THEN CLEAR HIS AC
	UUOEXT		/ AND EXIT

K0005,	5
CONOU7,	TAD JOBTBA	/IS HE DOWN TO MINBUF BUFFERS?
	DCA JOBSWA	/PINTS TO JOBTBL ENTRY
	CDF
	TAD I CONT1A	/POINTS TO DDB EMPTY PTR
	JMS I CNBUFS	/IS HE DOWN TO MINBUF BUFFERS YET?
	 -MINBUF
	SKP
	JMP I CON20A	/STILL MORE THAN MINBUF--DON'T TURN HIM ON
	CDF		/YES, GO INDICATE THAT HE HAS ROOM
	TAD JOBSWA
	JMP I .+1
	CONO70

CNBUFS,	BUFSIZ
CONT1A,	CONT1
CON20A,	CONO20
	PAGE
/BLOCK TRANSFER
/CALL	BLT
/	 62S1	SELECT SOURCE DATA FIELD
/	 SOURCE
/	 62D1	SELECT DESTINATION DATA FIELD
/	 DESTINATION
/	 -NUMBER WORDS
/	RETURN

BLT0,	0
	TAD I BLT0	/GET SOURCE FIELD SELECT
	DCA BLT1
	ISZ BLT0	/POINTS TO SOURCE ADDRESS
	STA
	TAD I BLT0	/CORE ADDRESS -1 OF SOURCE
	DCA AXS1
	ISZ BLT0	/POINTS TO DESTINATION FIELD SELECT
	TAD I BLT0	/GET DESTINATION SELECT
	DCA BLT2
	ISZ BLT0	/POINTS TO DEST. ADD
	STA
	TAD I BLT0	/DEST. ADD-1
	DCA AXS2
	ISZ BLT0	/POINTS TO - WORD COUNT
	TAD I BLT0
	DCA BLTC
	ISZ BLT0	/RETURN ADDRESS
	RDF
	TAD C6203
	DCA BLTF	/SAVE RETURN FIELD SELECT

BLT1,	0		/SELECT SOURCE DATA FIELD
	TAD I AXS1
BLT2,	0		/SELECT DESTINATION DATA FIELD
	DCA I AXS2
	ISZ BLTC	/DONE
	JMP BLT1	/NO
BLTF,	0		/RETURN
	JMP I BLT0
/TEST JOB FOR RUNABILITY
/CALL	TAD JOB #
/	RUNABLE
/	NOT RUNABLE
/	RUNABLE

BLTC,
RUNTST,	0		/COME HERE WITH JOB # IN AC
	TAD JOBTBA		/TO GET JOBTABLE ADDRESS
	GETJTI		/GET STR0
	 JOBSTS
	SMA CLA		/RUN BIT ON?
	JMP I RUNTST	/NO
	DATFLD		/YES, SEE IF IT RAN AS A COMPUTE BOUND JOB LAST TIME
	TAD I JOBSWA	/GET THE CONTENTS OF STR0
	AND C1000	/IS BIT 1000 ON SHOWING THAT IT WAS A COMPUTE BOUND JOB
	SNA		/SNA
	JMP RUNTS2	/NO, IT MAY BE READY TO RUN TEST FURTHER
	CMA		/LAST TIME IT WAS COMPUTE BOUND, SKIP THIS TURN
	AND I JOBSWA	/CLEAR THE BIT 1000, SO THAT IT WILL RUN NEXT TIME
	DCA I JOBSWA
	JMP RUNTS1+1	/RETURN BY NOT RUNNABLE EXIT
RUNTS2,	TAD JOBSWA	/GET THE ADDRESS OF STR1-1 IN AC
	DCA AXS1
	CLA CLL CML RTL	/AC =2
	TAD JOBSWA	/ADDRESS OF MASK1-1
	DCA AXS2
	TAD I AXS1
	AND I AXS2	/ANY STR1- MASK1 MATCHES?
	SZA CLA
	JMP RUNTS1	/YES
	TAD I AXS1
	AND I AXS2		/ANY STR2-MASK2 MATCHES?
	SZA CLA
RUNTS1,	ISZ RUNTST	/YES
	CDF		/NO
	JMP I RUNTST
/SET SYSTEM ERROR CODE
/CALL	TAD JOB #
/	ERROR
/	 ERROR CODE
/	NORMAL RETURN


SYSERR,	0
	AND C0037	/JOB # ONLY
	SNA		/IS IT JOB 0?
	JMP SYSER1	/YES - RETURN
	TAD JOBTBA	/POINTER TO JOBTBL
	GETJTI		/GET CURRENT VALUE OF STR0
	 JOBSTS
	AND C0007	/EXTRACT ANY ERROR CODE IN THERE
	SZA CLA		/ANY OLD BITS LYING AROUND?
	JMP SYSER1	/YES; DON'T CONFUSE THE ISSUE
	TAD I SYSERR	/GET THE ERROR CODE SUPPLIED
	DATFLD
	TAD I JOBSWA	/ADD IT TO OLD VALUE OF STR0
	DCA I JOBSWA	/SAVE THE WHOLE MESS
	ISZ JOBSWA
	TAD JOBSWA	/POINTS TO STR1
	IOR		/SET THE "ERROR HAS OCCURRED" BIT IN STR1
	 JSERR
SYSER1,	CDF
	ISZ SYSERR	/SKIP ARGUMENT IN CALL
	JMP I SYSERR	/RETURN
/SET KEYBOARD BREAK

UKSBT1=	JOBSWA
	IFNZRO DDBBRK-2	<GLITCH; *.-1>
UKSBRK=	C0002	/DDBBRK

UKSB,	TAD JOB
	TTYUSE		/FIND USER INPUT TTY DDB
	 0		/ (INPUT SIDE)
	TAD UKSBRK
	DCA UKSBT1	/POINTS TO BREAK MASK IN DDB
	TAD L2SA	/USER AC
	DATFLD
	SZA
	JMP I .+4	/HE HAS NEW MASK--GO PICK IT UP
	TAD I UKSBT1	/HE WANTS TO READ OLD MASK
	DCA L2SA	/GIVE IT TO HIM
	UUOEXT
	UKSB1

/SKIP IF DISC NOT ACTIVE
/CALL	TAD FIELD #
/	JMS DSKACT
/	ACTIVE
/	NOT ACTIVE

DAUTBL,	DSUTBL-1

DSKACT,	0
	CLL RTL		/FIELD #*4 IS MAJOR INDEX IN DSUTBL
	TAD DAUTBL	/START OF TABLE-1
	DCA AXS1	/AUTO INDEX
	DATFLD
	TAD I AXS1	/FILE 1 BUSY?
	TAD I AXS1	/  "   2   "
	TAD I AXS1	/  "   3   "
	TAD I AXS1	/  "   4   "
	CDF
	SNA CLA		/IF ANY ONE WAS BUSY, AC.NE.0
	ISZ DSKACT	/NO ACTIVITY; INDEX RETURN
	JMP I DSKACT	/AND OFF
/START USER DISC REQUEST FROM QUEUE
/IF THIS ROUTINE IS CALLED, THERE HAD
/BETTER BE SOMETHING IN SQREQ OR DSUTBL
/FOR IT TO FIND. IT WON'T STOP LOOKING!
/CALL	JMS DSUSER
/	RETURN

DSUSER,	0
	TAD SQREQ	/IS A SWAP REQUESTED?
	SZA CLA
	JMP DSUSR5	/YES, DO IT FIRST
	DATFLD
DSUSR4,	IAC
	TAD I DSKPTR	/GET ENTRY FROM DSUTBL
	SNA		/END OF LIST SET TO -1; AC.EQ.0 IF WE'RE THERE
	JMP DSUSR2	/YES. RESET POINTER TO START OF TABLE
	CIA
	CMA		/SUBTRACT ONE FROM ENTRY
	SNA		/IS IT A REQUEST?
	JMP DSUSR4	/NO
	CDF
	DSGO		/YES, START IT UP
	JMP I DSUSER	/AND BACK
DSUSR5,	JMS I SWPIOA	/START A SWAP DISC IO
	JMP I DSUSER	/RETURN BACK


DSUSR2,	TAD DAUTBL	/START OF 'DSUTBL'
	DCA DSKPTR
	JMP DSUSR4
	PAGE

/TELEPRINTER IOTS

UTELC=	WS0
UTELSR,	TTYSR1	/DEVTBL ENTRY POINTER (IN 'TTYUSE')

UTEL,	TAD JOB		/SET UP SOURCE FOR CHARACTER DISTRIBUTION
	AND C0037
	TAD C0100	/BIT 5=1 FOR PROGRAM TYPING OUT
	DCA SOURCE
	TAD JOB
	TTYUSE		/GET THE OUTPUT DEVTBL POINTER
	 1
	CLA
	TAD I UTELSR
	DCA UTELDB	/SAVE POINTER TO DEVTBL FOR DEVICE
	JMS UKT1	/WHAT IS REQUESTED BY USER?
	JMP UTELS	/SEND A STRING(6040)
UTELFL,	 JSTEL		/DELIMITER FLAG
	JMP UTELS4	/FLAG TEST AND NO ROOM - EXIT & CLEAR JSTEL
	SNA CLA		/IS IT A 6044?
	JMP UTEL3	/NO - CHECK FOR 6042
	TAD L2SA	/6044 (POSSIBLY MICRO CODED)
	JMS UTELO	/"OUTPUT" THE CHARACTER
	SKP		/NO ROOM - REDO LATER
	UUOEXT		/OK - ALL DONE
	STA		/BACK UP HIS PC
	TAD L2SV0
	DCA L2SV0
	SKP CLA
UTEL3,	SZL CLA		/WAS 6042 CODED?
UTELS4,	TAD UTELFL	/YES - CLEAR FLAG
	UUOEXT		/ AND EXIT

/THIS ROUTINE PUSHES CHAR IN TTCHAR
/THROUGH GIR
/
UTELO,	0
	DCA TTCHAR
	CDF
	GIR
UTELDB,	0		/POINTS TO OUTPUT DDB
	JMP I UTELO	/NO ROOM IN BUFFER
	ISZ UTELO	/SUCCESSFULLY STORED
	JMP I UTELO	/RETURN

UTELS,	TAD L2SA	/HANDLER FOR "SEND STRING"
	IAC
	DCA UTELC	/POINTS TO ADDRESS OF STRING IN USER AREA
	TAD L2SA
	DCA UKT1	/SET POINTER TO USER'S WORD-COUNT
	DCA L2SA	/ AND CLEAR THE USER'S AC
	UDF
	TAD I UTELC	/GET ADDRESS-1 OF STRING
	DCA AXS2	/SAVE POINTER TO STRING
UTELS3,	TAD I AXS2	/GET CHARACTER FROM USER
	JMS UTELO	/ & PUSH IT THROUGH GIR
	JMP UTELS4	/BUFFER FULL - SET FLAG & EXIT
	UDF
	ISZ I UTELC	/BUMP ADDRESS IN USER AREA
	NOP
	ISZ I UKT1	/BUMP USER'S WORD COUNT
	JMP UTELS3	/KEEP GOING
	JMP I .+1	/ALL DONE - EXIT AND SKIP
	UUOEX2
/ROUTINE TO ANALYZE IOT'S
/CALLING SEQUENCE
/	IOT IN UUOCAL
/	JMS UKT1
/	RETURN FOR STRING IOT
/	FLAG TO CHECK IN STR1
/	RETURN FOR NON SKIPPING FLAG TESTS
/	RETURN FOR SKIPPING FLAG TEST OR EVENT TIMESS 2 AND 4
/		(AC=BIT 9 OF IOT; LINK=BIT 10)
UKT1,	0
	TAD UUOCAL
	AND C0007
	SNA		/STRING?
	JMP I UKT1	/YES
	ISZ UKT1
	CLL RAR		/NO
	DCA UUOCAL
	SNL		/SKIP TEST?
	JMP UKT12	/NO
	GETJTW		/YES, IS IT POSITIVE OR NEGATIVE
	 JOBSTS+1
	AND I UKT1	/FLAG TO CHECK
	ISZ UKT1	/INDEX PAST ARGUMENT
	SNA CLA		/FLAG SET?
	JMP UKT13	/NO - DON'T SKIP
	ISZ L2SV0	/YES - SKIP
	NOP
	SKP
UKT12,	ISZ UKT1
	ISZ UKT1
	TAD UUOCAL	/YES -PUT?
	CLL RAR
	JMP I UKT1	/INDEX RETURN
	USKIOT		/USER IOT SKIP FLAG (CHECKED BY UUOEXT)
UKT13,	ISZ I .-1
	JMP I UKT1	/INDICATE FLAG TEST IOT THAT DIDN'T SKIP
/WE GOT A 'DRL' ERROR ON THE DISC - ASSUME IT WAS THE
/ACTIVE JOB DOING 'EAE' STUFF AND PUT IT TO SLEEP.
SLEEP,	STA
	TAD DSKPTR	/BACK UP DSKPTR
	DCA DSKPTR
SLEEP2,	JMS I FIUSER	/NOW START UP THE I/O AGAIN
	TAD JOB
	SNA CLA		/WAS ANY JOB ACTIVE?
	EXIT		/NO - JUST EXIT & HOPE IT WORKS
	JMP I .+1	/YES - GO PUT IT TO SLEEP FOR 2 SECONDS
	DOXSTM

/ROUTINE TO MAKE AN ENTRY ON THE LEVEL 2 INTERRUPT QUEUE.
L2QUER,	0		/ENTER WITH DISPATCH ADDRESS
	DCA L2QENT	/SAVE INT SERVICE ADDRESS
	RTR		/ & THE LINK
	DCA L2QLNK
	TAD L2Q
	CIA
	TAD L2QE
	SZA CLA		/ARE THE POINTERS CAUGHT UP?
	JMP .+5		/NO
	TAD L2QINI	/YES - RE-INITIALIZE THEM
	DCA L2Q		/ TO FORESTALL ANY OVERFLOW
	TAD L2QINI
	DCA L2QE
	TAD L2Q
	TAD L2QEND
	SMA		/REACHED ABSOLUTE END?
	REBOOT		/YES - JUST CRASH *****
	TAD C0007
	SPA CLA		/NO - PAST OUR DANGER MARK?
	JMP L2QGO	/NO - WE'RE FINE
	TAD L2QENT
	TAD L2QRTC
	SNA CLA		/YES - WAS THIS A CLOCK INTERRUPT?
	JMP .+3		/YES - JUST DON'T QUEUE IT
L2QGO,	TAD L2QENT
	DCA I L2Q	/QUEUE UP THE LEVEL-2 REQUEST
	TAD L2QLNK	/RESTORE THE LINK
	CLL RTL
	JMP I L2QUER	/ AND RETURN

L2QEND,	-L2QTB-20	/POINT AT WHICH WE CRASH
L2QINI,	L2QTB-1
L2QLNK,	0
L2QRTC,	-L2TIME
L2QENT,	0

	IFNZRO OVERLA-.&4000	<GLITCH; *.-1>
	*OVERLA
OVERLA,	JMP SLEEP	/PUT EAE TO SLEEP
	JMP I .+1	/OK, FINISH IT UP
	OVERL1
	PAGE

UUOUDF,	UDFSET
UHALTA,	UHALT
UUOTBA,	UUOTBL-1
UUOTLL,	UUODTB-UUOTBL
C0770,	0770
C0777,	0777

UUOCAL=	WS0

UUO,	STA		/GET POINTER TO USER PARAMETERS-1
	TAD L2SA
	DCA UUSRC	/SAVE FOR POSSIBLE BLT CALL
	STA
	TAD L2SV0	/BACK UP USER PC TO POINT TO IOT IN QUESTION
	DCA UUOCAL
	JMS I UUOUDF	/SET USER DATA FIELD SELECT
	UDF		/SELECT USER DATA FIELD
	TAD I UUOCAL	/GET THE IOT THAT CAUSED ENTRY HERE
	CDF
	DCA UUOCAL	/SAVE IT
	IFZERO CPU-3  <
	TAD UUOCAL	/REGET THE IOT IF WE WANT TO TEST FOR A
	JMS I UUODSP	/6124, WHICH IS THE UUO. IF NOT RETURN.  >
	TAD UUOCAL	/IS IT AN IOT OR A GROUP 2 OPERATE
	AND C1000
	SZA CLA
	JMP I UHALTA	/IT'S A HLT, OSR, OR SOME COMBINATION
	TAD UUOTBA	/IT'S AN IOT; NOW FIGURE OUT WHICH ONE
	DCA AXS1

/FIRST SEARCH FOR COMBINED RESIDENT IOTS (I.E. DEVICES)
	TAD UUOCAL	/FIRST SEE IF IT MIGHT BE MICRO-CODED
	AND C0770	/GET DEVICE CODE
	CIA
	DCA UUOC77	/SAVE-CODE
	TAD I AXS1	/GET ENTRY FROM DEVICE LIST
	SNA		/END OF LIST?
	JMP UUO22	/YES - IT'S NOT ONE OF THESE
	TAD UUOC77	/COMPARE WITH THIS CODE
	SZA CLA		/THIS IOT?
	JMP .-5		/NO, KEEP GOING
UUO3,	TAD AXS1	/YES, NOW COMPUTE ADDRESS OF SERVICE ROUTINE
	TAD UUOTLL	/OFFSET BETWEEN IOT TABLE AND DISPATCH TABLE
	DCA UUOC77	/POINTS TO DISPATCH ENTRY
	TAD I UUOC77	/GET DISPATCH ADDRESS
	DCA UUOC77	/SAVE IT
	JMP I UUOC77	/AND JUMP TO IT
/SEARCH FOR UNCOMBINED RESIDENT IOTS
UUO22,	TAD UUOCAL	/IT'S NOT MICROCODED
	CIA
	DCA UUOC77	/-IOT CAUSING INTERRUPT
	TAD I AXS1	/GET IOT FROM TABLE
	SMA		/AT END OF LIST YET?
	JMP UUO4	/YES (LIST TERMINATED BY 0)
	TAD UUOC77	/THIS YET?
	SZA CLA
	JMP .-5		/NO; KEEP LOOKING
	JMP UUO3	/YES; NOW GO GET DISPATCH ADDRESS AND AWAY---

/SEARCH FOR SHORT NON-RESIDENT IOTS
UUO4,	TAD I AXS1	/NOW WE'RE LOOKING FOR IOT'S HANDLED BY F/
	SNA		/END OF LIST?
	JMP UUO7	/NOT YET
	TAD UUOC77	/THIS IOT?
	SZA CLA
	JMP UUO4	/NO; KEEP LOOKING HERE
	TAD UUOCAL	/YES; THROW AWAY BITS 0-2 OF IOT
	AND C0777
	DCA UUOCAL	/AND SAVE IT
	JMP UUO8	/THEN SET UP FOR FIP

UUO7,	TAD I AXS1	/LOOK FOR IOT'S RETURNING MULTIPLE ARGUMENTS
	SNA		/END OF LIST - IF SO, IT'S UNDEFINED
	JMP I UUOERA	/ SO IT'S AN "ILLEGAL IOT"
	TAD UUOC77	/IS IT THIS IOT
	SZA CLA
	JMP UUO7	/NO, KEEP GOING

/WE NOW FIND OUT HOW MANY PARAMETERS ARE TO BE PASSED TO
/FIP AND SET UP THE 'JOBLNK' PARAMETER BLOCK.
UUO8,	TAD AXS1	/NOW FIND NUMBER OF ARGUMENTS
	TAD UUOTLL	/THIS POINTS TO # IN UUOTBL
	JMS GETUSP	/GET USER PARAMETERS
	TAD CJOBDA	/GET POINTER TO STR0
	GETJTA
	 JOBSTS
	DATFLD		/OR IN "NON RESIDENT IOT" BIT
	IOR		/SO F/P WILL RUN IN PLACE OF THIS JOB
	 JSIOT
	WAIT		/AND WAIT FOR FIP
/ROUTINE TO HANDLE THE CLEAR-STATUS (CLS) IOT.
UCLS,	GETJTW		/GET THE ADDRESS OF STR0 INTO JOBSWA
	 JOBSTS
	CLA CLL CMA RTL	/AC = -3
	JMS I UCSTOA	/CLEAR STR0 - STR2 ACCORDING TO MASK
	DCA L2SA	/THEN CLEAR USER'S AC
	UUOEXT		/ & EXIT

UCSTOA,	UCSTO

UPHANA,	TAD JOB
	ERROR		/INIDICATE HUNG DEVICE
	 HUNGDV
	WAIT		/ AND RESCHEDULE
/THIS ROUTINE COPIES THE PARAMETERS SUPPLIED BY THE
/USER PROGRAM INTO *BLOCK IN FREE CORE, WHICH IS POINTED
/TO BY JOBLNK.
/THE IOT ITSELF IS SAVED IN THE FIRST WORD OF THE PARAMETER BLOCK
/IF NO ARGUMENTS ARE REQUIRED, JOBLNK CONTAINS THE IOT,
/RATHER THAN A POINTER TO THE IOT PARAMETER BLOCK.
/FIP CAN TELL BY EXAMING BITS 0-2 OF JOBLNK: IF THEY ARE
/NON-ZERO; JOBLNK IS AN ADDRESS. IF ZERO; JOBLNK IS THE IOT ITSELF
/NOW YOU KNOW WHY THE START OF THE  FREE CORE LIST MUST ALWAYS BE
/ON OR AFTER 1,000 OCTAL IN FIELD ONE?

UUODAC,	DSKACT

GETUSP,	0		/ENTER WITH PTR -# ARGUMENTS TO GET
	DCA UUOC77	/SAVE IT
	TAD L2SF	/GET THE USER'S FIELD
	AND C0007
	JMS I UUODAC	/ANY DISC REQUESTS PENDING IN THAT FIELD?
	REDO		/YES-DEFER THIS IOT UNTIL SUCH ACTIVITY CEASES
	CLL CLA CMA RAL	/DISC QUIET-CAN WE GET PARAMETER BLOCKS?
	TAD FRECNT
	SPA SNA CLA
	REDO		/NO-TRY LATER
	TAD CJOBDA	/OK-NOW  GET PTR TO JOBLNK
	GETJTA
	 JOBLNK
	DCA UUOLNK	/AND SAVE IT
	TAD I UUOC77
	SNA		/ANY ARGUMENTS?
	JMP GETUS1	/NO-JUST SAVE IOT IN JOBLNK
	DCA UUOC77	/YES. SAVE # ARGUMENTS
	TAD UUOLNK	/PUT ADDRESS OF LINKAGE BLOCK IN UUOLNK
	GETBLK		/GET A FREE BLOCK
	REDO		/NONE AVAILABLE. TRY AGAIN LATER
	DATFLD
	TAD I UUOLNK	/GET ADDRESS OF PARAMETER BLOCK
	CDF
	DCA UUOLNK	/SAVE IT IN BLT CALLING SEQUENCE
	TAD UUDF	/MOVE USER PARAMETERS TO LINKAGE AREA IN DATFLD
	DCA .+2
	BLT
	 0		/SOURCE FIELD SELECT
UUSRC,	 0		/SOURCE ADDRESS
	 DATFLD		/DESTINATION FIELD SELECT
UUOLNK,	 0		/DESTINATION ADDRESS
UUOC77,	 0		/-#WORDS
GETUS1,	TAD UUOCAL	/NOW GET IOT
	DATFLD
	DCA I UUOLNK	/AND SAVE IT IN APPROPRIATE PLACE
	CDF
	JMP I GETUSP	/RETURN
	IFNZRO CPU-3 <
/DECTAPE FIELD 0 DISPATCHES
	IFZERO TC01-1 <
	IFNZRO DTL20-.&4000	<GLITCH; *.-1>
	*DTL20
DTL20,	CIF DATFLD	/LEVEL 2 DISPATCHER
	JMP I .+1
	DTL21
	>>
	IFZERO CPU-3 <
UUODSP,	DISCHK		/POINTER TO DISPLAY ROUTINE IF DESIRED.
	>
	PAGE

CLKTMR,	CLKMIS
L2COUT,	CHOUT
L2OUTA,	CONOUT
SCHNJN=	WS0
SCHE1A,	SCHED1
ICLK2,	-INCLK2-1
ICLK1,	-INCLK1

/LEVEL-2 CLOCK HANDLER:
/	INCREMENT OUR DAY-CLOCK
/	RUN THE JOB WAIT-TIMERS
/	FORCE-FEED THE TELETYPES
/	CHECK FOR HUNG DEVICES
/	DECREMENT JOB'S QUANTUM & RESCHEDULE IF NECESSARY
/
L2TIME,	TAD C7400
	DCA I CLKTMR	/RESET CRASH-CHECK TIMER
	ISZ CLK1	/UPDATE LOW ORDER DAY CLOCK
	JMP L2TIM1
	ISZ CLK2	/UPDATE HIGH ORDER TIME. WOW!
	JMP L2TIM1
	ISZ DATE	/MIDNIGHT - INCREMENT THE DATE
	TAD ICLK2	/REINITIALIZE THE CLOCK FOR ANOTHER
	DCA CLK2	/ 24 HOURS WORTH OF TICKS
	TAD ICLK1
	DCA CLK1

/NOW WE DECREMENT ALL THE JOB WAIT-TIMERS (FROM 'STM').
L2TIM1,	CIF DATFLD
	JMS I TIMERA	/FIELD 1 ROUTINE TO RUN TIMERS

/HERE WE FORCE-FEED ALL THE TELETYPES.  IF THE
/ECHO-ROUTINE HAS BEEN SCHEDULED, WE DON'T HAVE
/TO DO ANYTHING, SINCE ECHO WILL FEED THEM WHEN
/IT HAS FINISHED; THEN WE JUST ZERO THE ECHO-FLAG
/SO IT COULD NEVER WRAP-AROUND IN A BUSY SYSTEM.
/
	IOF		/CAN'T INTERRUPT WHILE CHECKING 'TBUFF'
	ISZ I ECHOFA	/IS THE ECHOING ROUTINE SCHEDULED?
	JMP .+3		/YES - THEN WE NEEDN'T FEED THE TERMINALS
	JMS I L2OUTA	/NO - FEED ALL THE HUNGRY TELETYPES
	CLA CMA		/ AND RESET THE FLAG
	ION
	DCA I ECHOFA
/NOW WE INCREMENT OUR ACTIVE DEVICE TIMERS, CHECKING
/FOR HUNG DEVICES.  IF THERE ARE ANY, THEY GET A SEPARATE
/LEVEL-2 ACTIVITY SCHEDULED TO HANDLE THEM.
PTPSKA,	NOP		/WHEN PUNCH IS ON ISZ
	SKP
	JMP PTHUNG	/PUNCH IS HUNG
PTRSKA,	NOP		/WHEN READER IS ON-ISZ
	JMP L2TIM2
	IAC		/READER IS HUNG
PTHUNG,	TAD PTHSER	/SCHEDULE LEVEL 2 SERVICE FOR HUNG PUNCH
	DCA I L2Q	/ VIA L2QUE

L2TIM2,	TAD JOB
	SNA CLA		/IS NULL-JOB RUNNING?
	JMP SCHED2	/YES - GO FIND SOMETHING MORE PRODUCTIVE
	ISZ JOBTIM	/NO. TIME OUT?
	EXIT		/NO - BACK TO USER JOB

/"RSCHED" IS ENTERED AT THIS POINT
/RSCHED'S FUNCTION IS TO FIND JOBS TO RUN, REGARDLESS
/OF WHERE THEY MAY CURRENTLY RESIDE. IF THEY ARE IN CORE,
/GOOD; IF NOT THE NECESSARY STEPS WILL BE TAKEN TO
/BRING THEM INTO CORE. IN THE LATTER CASE, WE WILL THEN
/GO OFF AND FIND SOMETHING TO DO WHILE THE NON-RESIDENT
/JOB IS MADE RESIDENT

SCHED0,	TAD JOB		/NULL JOB?
	SNA CLA
	JMP SCHED2	/YES
	TAD JOBTIM	/IS JOB RUNNING ON BORROWED TIME?
	SPA CLA
	EXIT		/NO, GO BACK TO IT
WSCHED,	SAVJOB		/YES. SAVE IT'S STATE. JOB:=0 ('WAIT' ENTRY)
SCHED2,	CLA CMA
	TAD I SCHMUC	/INITIALIZE THE # OF USER CORE FIELDS TO
	DCA SCHEI4	/ STUDY AT THIS TIME
	TAD SQREQ	/SWAP REQUEST IN PROGRESS?
	SNA CLA		/IF SO, THERE IS NO POINT IN GOING FURTHER NOW.
	JMP I SCHE1A	/NO - PROCEED
			/YES, SINCE A SWAP IS IN PROCESS, RUN SOME OTHER
			/RESIDENT JOB NOW.
/SCHEDULE NEXT RESIDENT JOB
/THIS IS THE ENTRY FOR "SCHED"
/WE ONLY COME HERE AFTER FINDING THE JOB WE REALLY
/WANT TO RUN IS CURRENTLY INDISPOSED TO RUNNING. SCHED
/WILL FIND SOME RESIDENT JOB TO RUN. IF NO JOB IS
/RUNNABLE OR RESIDENT, JOB 0 (THE NULL JOB) IS RUN.

SCHEDI,	TAD COMCNT	/ANY SI COMMANDS WAITING?
	SNA CLA
	JMP SCHEI1	/NO - GO LOOKING FOR USER JOB
	TAD SCHSI	/YES - SCHEDULE SI IMMEDIATELY?
	JMP I SCHE2A
SCHEI1,	ISZ SCHEI4	/HAVE WE SCHEDULED EVERY FIELD
	JMS I SCHNXT	/NO, FIND RESIDENT JOB
	SNA
	JMP I SCHNUA	/RUN NULL JOB
	JMP I .+1	/RUN IT
	SCHEI3

PTHSER,	PTRHNG	/LEVEL-2 SERVICE ROUTINE FOR PAPERTAPE
SCHNUA,	SCHNUL
SCHMUC,	CORCNT	/POINTER TO NUMBER OF USER FIELDS
SCHNXT,	NXTCOR
	IFNZRO SI-200	<GLITCH; *.-1>
SCHSI=	C0200	/SI
SCHE2A,	SCHEI2
TIMERA,	TIMER0

TIPTR1,			/#OF TICKS BEFORE READER IS HUNG
	IFZERO CPU-3  <-200>
	IFNZRO CPU-3  <-25>
	0		/READER COUNTER
PTRISZ=	ISZ TIPTR1+1

TIPTP1,
	IFZERO CPU-3 <-400>	/# OF TICKS BEFORE PUNCH IS HUNG
	IFNZRO CPU-3 <
		IFZERO LPT <-150>
		IFNZRO LPT <-400>>
	0		/PUNCH TIMER
PTPISZ=	ISZ TIPTP1+1
/TELETYPE ECHOING SERVICE
/ENTERED FROM L2QUE WHENEVER CHARACTER IS
/RECEIVED PUSHES CHARACTER THROUGH GIR

ECHO,	STA
	DCA I ECHOFA	/RESET FLAG

	IFZERO D680-2 <
/TTY CHARACTER INPUT
	TAD KCHAR
	SNA		/CTY INPUT?
	JMP ECHO0	/NO
	AND C0377	/YES, CLEAR HOUSEKEEPING BITS
	DCA TTCHAR	/YES - SAVE CHARACTER
	DCA KCHAR	/INDICATE NO CONSOLE CHARACTER
	JMP .+4		/SOURCE IS K00
	>
ECHO0,	T8SIR		/KEYBOARD INPUT FROM DC08 SYSTEM?
	JMP ECHO1	/NO CHARACTERS TO DELIVER
IFZERO D680-2 <	IAC>	/INCREMENT LINE # TO CONVERT TO TSS/8 CONSOLE #
	DCA SOURCE	/SAVE ORIGINATING KEYBOARD #
	TAD SOURCE
	CLL RAL		/GET DEUTBL INDEX (=2*LINE #)
	TAD DEVTBA	/GENERATE DEUTBL POINTER
	DCA L2TBA	/DEVICE TABLE ADDRESS+2*LINE#
	DATFLD
	TAD I L2TBA
	CDF
	SZA CLA		/IS THERE ALREADY A DDB FOR THIS CONSOLE?
	JMP ECHO2	/YES - WE ALREADY KNEW ABOUT IT.
	TAD L2TBA	/NO - IT MUST BE A NEW JOB
	GETDDB		/GET A DDB
	JMP L2BELL	/NONE AVAILABLE - RING A BELL
	DATFLD
	TAD I L2TBA	/OR IN THE SI BIT IN WORD 1 OF DDB
	IOR		/DEST:=S.I.
	 DSI
	CDF
ECHO2,	GIR		/NOW CALL GIR TO HANDLE THE CHARACTER
SCHEI4,
L2TBA,	 0
	JMP L2BELL	/WON'T FIT - RING A BELL
	JMP ECHO0	/NEXT LINE

L2BELL,
	IFZERO CPU-3  <IOF>
	JMS I L2COUT	/OUTPUT A BELL; CHARACTER WAS LOST
	4207
	IFZERO CPU-3  <ION>
	JMP ECHO0

ECHO1,	IOF		/STATUS CHECKING CAN'T BE INTERRUPTED
	JMS I L2OUTA	/OUTPUT CHARACTERS RECEIVED
	ION
	EXIT		/ AND EXIT LEVEL 2

ECHOFA,	ECHOFL		/POINTER TO ECHO FLAG
	/ROUTINE TO HANDLE CONSOLE TTY
	/FOR PT08 SYSTEMS, CONSOLE IS JUST ANOTHER PT08
	/"TCHAR" CONTAINS THE CONSOLE TTY CHARACTER
	/IT CAN HAVE THREE STATES:
	/	0	 - NO NEW CHARACTER TO OUTPUT - STOP TELEPRINTER
	/	MINUS	 - CHARACTER ALREADY OUTPUT   - STOP TELEPRINTER
	/	POSITIVE - CHARACTER WAITING TO BE OUTPUT

	IFZERO D680-2 <
TINT2,	TAD TCHAR	/WHICH STATE ARE WE IN
	SPA SNA CLA
	JMP TINT1	/CHARACTER IS OLD - FORGET IT
	TAD TCHAR	/OUTPUT CHARACTER
	TLS
	STL RAR		/REMEMBER IT'S BEEN OUTPUT
	SKP
TINT1,	TCF		/CLEAR FLAG
	DCA TCHAR	/SAVE TCHAR STATUS
	DISMIS		/ALL DONE
	>
		IFZERO CPU-3 <
DISCHK,	0			/COMES HERE TO CHECK TO A 614X CLASS INSTRUCTION
	AND	C7770		/JUST GET THE DEVICE SELECTOR BITS.
	TAD	DISLIT		/CHECK FOR BEING IN THE 614X CLASS
	SZA CLA
	JMP I	DISCHK		/NOT IN THE CLASS. RETURN
	TAD	UUOCAL		/REGET THE IOT
	AND	C0007		/JUST GET THE IOP PULSE BITS
	CDF CIF	10		/SET TO UPPER CORE
	JMS I	DISGO		/AND GO THERE
	JMP I	DISCHK		/COMES HERE IF NOT LEGAL IOT
	UUOEXT			/COMES HERE IF ALL IS WELL
	>
	IFNZRO 2574-.&4000	<GLITCH; *.-1>
	*2574
/NULLJOB IS THE ONLY CODE IN FIELD 0 WHICH
/RUNS IN USER MODE.
/IT IS RUN WHENEVER THERE IS NOTHING ELSE
/TO DO, OR NOTHING ELSE THAT CAN BE DONE
/
/WHEN DEBUGGING THE MONITOR, IT IS POSSIBLE
/TO STOP (VIA THE PDP-8 OPERATOR CONSOLE) THE MONITOR
/TO ENTER XDDT.  THIS MAY ONLY BE DONE
/WHEN THE SYSTEM IS IN NULJOB.  IF THE 
/SYSTEM IS STOPPED WHEN NOT IN NULJOB, IT MAY
/BE RESTARTED BY HITTING "CONTINUE", AND THEN
/STOPPED AGAIN.  KEEP TRYING - EVENTUALLY YOU'LL CATCH IT
/DON'T TRY TO STOP THE SYSTEM (AND GET AWAY WITH IT)
/IF THE DISC OR DECTAPE IS ACTIVE.
/IF THE SYSTEM IS STOPPED IN NULJOB, IT MAY BE
/RESTARTED AT LOCATION 4201 IN FIELD 0.

	IFNZRO CPU-3 <
NULJOB,	ISZ WS0
	JMP .-1
	IAC		/DISPLAY A BINARY-COUNT WHEN IDLE
	JMP .-3
	>
	IFZERO CPU-3 <
NULJOB,	JMP I .+1	/GO TO THE DISPLAY IDLE ROUTINE.
	DISIDL		/DISPLAY IDLE MESSAGE.
DISGO,	PDPEXT
DISLIT,	-6140
	>
	PAGE

SCHNXA,	NXTJOB
	IFNZRO JSIOT-100	<GLITCH; *.-1>
SCJIOT=	C0100	/JSIOT
	IFNZRO FIP-400	<GLITCH; *.-1>
SCFIP=	C0400	/FIP
	IFNZRO SI-200	<GLITCH; *.-1>
SCSI=	C0200	/SI
	IFNZRO LOCK-2000	<GLITCH; *.-1>
SCLOCK=	CLA CLL CML RTR	/LOCK BIT  AC = 2000
	IFNZRO FSWP-4000	<GLITCH; *.-1>
C4037,	4037	/FSWP + JOB # MASK
SCDACT,	DSKACT
	IFNZRO JSEREN-2000	<GLITCH; *.-1>
SCHERN=	CLA CLL CML RTR	/JSEREN BIT    AC = 2000
FANFLD=	C0002		/PHANTOMS ALWAYS RUN IN FIELD 2


SCHED1,	TAD FIT		/DO WE KNOW WHAT WE WANT TO BRING IN NEXT?
	SZA
	JMP SCHED3	/YES, SO SKIP AS MUCH CODE AS POSSIBLE
	TAD COMCNT	/NO. S.I. REQUEST?
	SZA CLA
	JMP SCHED6	/YES, SCHEDULE SI
SCHE13,	JMS I SCHNXA	/GET NEXT RUNABLE JOB
	SNA
	SCHED		/NONE TO RUN
	DCA FIT		/SAVE JOB #
	DCA BONUS	/BONUS JOB ALREADY PICKED UP
	TAD FIT
	TAD JOBTBA
	GETJTI		/GET CONTENTS OF STR0
	 JOBSTS
	DATFLD
	AND SCJIOT
	SZA CLA		/FIP REQUIRED?
	JMP SCHED7	/YES
	TAD I JOBSWA	/NO
	AND C0007
	SNA CLA		/ANY ERROR BITS SET?
	JMP SCHED9	/NO
	SCHERN		/YES
	AND I JOBSWA
	SNA CLA		/CAN HE HANDLE THE ERROR?
SCHED6,	TAD SCSI	/NO - CALL FOR SI
	SKP
SCHED7,	TAD SCFIP
	TAD FIT
	DCA FIT
SCHED9,	CDF
	TAD FIT
SCHED3,	AND C0600	/IS FIT JOB FIP OR SI?
	SNA CLA
	JMP SCHE11	/NO
	TAD I FANCOR	/IS FIP OR SI IN CORE?
	AND FIT
	AND C0600
	SNA CLA		/IS IT THE PROPER PHANTOM?
	JMP SCHE15	/NO- SCHEDULE THEIR SWAP IN
	TAD I FANCOR	/YES-IS THE PHANTOM ABOUT TO BE SWAPPED OR IN USE?
	AND C4037	/SWAP + JOB #
	SZA CLA
	JMP .+4		/YES-NOT MUCH TO DO NOW
	SCLOCK		/LOCK PHANTOM FOR THIS JOB
	TAD FIT		/NO-LOCK PHANTOM FOR THIS USER
	DCA I FANCOR	/INDICATE THAT THIS FIELD IS NOW LOCKED
	DCA FIT		/CLEAR FIT
	TAD I FANCOR	/IS THE SWAP COMPLETE?
	SPA CLA
	SCHED		/NO-FIND SOMETHING ELSE TO DO
	TAD FANFLD	/YES-DISC ACTIVITY HERE?
	JMS I SCDACT
	SCHED		/YES-FORGET ABOUT PHANTOM FOR NOW
	TAD I FANCOR	/NO
	JMP I .+1	/NOW GO FINISH BOOKKEEPING
	SCHEI2

SCHE11,	TAD FIT		/IS FIT JOB IN CORE?
	CORE
	 FSWP+LOCK+FIP+SI+37
	JMP SCHE10	/NO-HE HAS TO BE SWAPPED IN
	DCA L2SF	/SAVE FIELD
	TAD FIT		/RESTORE LEVEL 2 REGISTERS
	RESJOB
	DCA FIT		/CLEAR FIT
	START		/START JOB

SCHBSY,	FSWP+LOCK+NOTRUN+FIX

SCHE15,	TAD I FANCOR	/FANFLD LOCKED, SWAPPED, OR NOTRUN?
	AND SCHBSY	/ BIT 5 - IS PRESENT IF DISC I/O JUST COMPLETED
	SZA CLA
	JMP SCHE13	/YES- GO FIND SOMETHING ELSE TO DO NOW
	TAD I FANCOR	/IS THERE CURRENTLY A USER JOB IN FANFLD?
	AND C0037	/IS THERE A USER JOB IN FANFLD
	SZA CLA
	JMP SCHE16	/YES, FORCE IT OUT
	TAD FANFLD	/NO; FINISH:=FANFLD
	JMP SCHE14

SCHE16,	TAD I FANCOR	/IS A PHANTOM IN HERE?
	AND C0600
	SZA CLA
	JMP SCHE13	/YES, GO FIND ANOTHER JOB TO RUN
	TAD FANFLD	/FORCE JOB OUT OF FANFLD
	DCA FORCE
	JMP SCHFR1

SCHE10,	CORE		/HAVE A TOTALLY EMPTY FIELD?
	 7777
	JMP I SCHSCN	/NO - SCAN FOR SWAPPABLE FIELD
SCHE12,	AND C0007	/YES - GET THE FIELD NUMBER
SCHE14,	DCA FINISH	/FINISH:=FIELD #
	TAD FINISH	/SET SWAP BIT IN CORTBL ENTRY
	TAD CORTBA
	DCA SUJT2	/POINTS TO CORTBL ENTRY
	TAD FIT		/JOB TO SWAP IN
	TAD SCHSWP	/SWAP + NOTRUN
	DCA I SUJT2	/SAVE IN CORTBL
	JMP I SCSWAP	/SWAP IN
SCHFR1,	TAD FORCE	/DISC XFER IN PROGRESS?
	JMS I SCDACT
	SCHED		/YES - CAN'T FORCE IT OUT OR TRANSFER WILL BE MESSED UP
	TAD FORCE
	TAD CORTBA
	DCA SUJT2	/CORTBL POINTER TO FORCED FIELD
	TAD FORCE
	CIA
	DCA FINISH	/SET FINISH=-FORCE (TO INDICATE SWAP OUT)
	JMP I .+1	/NOW GO SET UP THE OUTSWAP
	SWPOUT

SCHSCN,	SCNSWP
SCHSWP,	FSWP+NOTRUN
SCSWAP,	SWAP
SUJT2=	WS0
/ROUTINE TO HANDLE THE 'ACT' IOT - RETURN ANY JOB'S ACCT #
UACT,	TAD L2SA	/GET THE DESIRED JOB #
	SNA		/HIS OWN JOB?
	TAD JOB		/YES
	AND C0037
	TAD JOBTBA
	GETJTI		/GET THE ACCOUNT #
	 JOBACT
	JMP UUSAC1	/ AND RETURN IT IN HIS AC

/RETURN SEVERAL SIMPLE VALUES TO THE USER.
	TICSPS
URCR,	TAD .-1		/RETURN THE REAL-TIME CLOCK-RATE
	JMP UUSAC1

UDATE,	TAD DATE	/RETURN TODAY'S DATE
UUSAC1,	DCA L2SA
	UUOEXT
	PAGE
SCHEI3,	DCA SCHNJN	/SAVE JOB #
	TAD SCHNJN
	AND C0037	/GET JOBTBL INDEX
	TAD JOBTBA	/GET POINTER TO JOB DATA
	GETJTI		/GET VALUE OF STR0
	 JOBSTS
	AND C0107	/DOES HE WANT TO RUN FIP OR SI FOR ERROR?
	SZA CLA
	JMP I SCHI1A	/YES - SCHEDULE FIP FOR HIM
	SKP		/NO
SCHEI2,	DCA SCHNJN	/IS JOB IN CORE?
	TAD SCHNJN	/SEARCH CORTBL FOR HIM
	CORE
	 FSWP+LOCK+FIP+SI+37
	JMP I SCHI1A	/NOT THERE; HAVE TO SWAP HIM IN
	DCA L2SF	/YES - SET UP SAVE FIELD
	TAD SCHNJN	/RESTORE REST OF LEVEL 2 REGISTERS
	RESJOB
	START		/START JOB

C0107,	107
SCHI1A,	SCHEI1

SWGOOD,	TAD CORTBA	/GET A POINTER TO THIS FIELD'S
	TAD FINISH	/ ENTRY IN CORTBL
	DCA SQREQ
	TAD FIT		/JOB SWAPPED IN
	TAD C1000	/NOT RUN BIT
SWGOD1,	DCA I SQREQ	/STORE IT IN THE CORTBL
	DCA FINISH
	DCA FIT		/SET ALL CONCERNED WORDS TO ZERO
	DCA FORCE
	DCA SQREQ
	JMS I SWSCON	/SEE IF ANY MORE DISC IO WAITING TO BE ATTENDED TO
	RSCHED		/RESCHEDULE
SWSCON,	DSKCON

SWERR,	TAD FINISH
	SPA		/WAS IT A SWAP-OUT OR SWAP-IN ERROR?
	CIA		/DURING SWAP OUT
	TAD CORTBA
	DCA SQREQ	/POINTER TO CORTBA FOR THIS FIELD
	TAD SWERER
	DCA SWPER1	/SET SWAP-IN ERROR CODE INITIALLY
	TAD FINISH
	SPA CLA		/WAS THIS A SWAP-IN OR -OUT ERROR?
	JMP .+3		/SWAP-OUT
	TAD FIT		/SWAP-IN - JUST GET JOB NUMBER
	JMP .+3
	ISZ SWPER1	/SWAP-OUT ERROR CODE = 3
	TAD I SQREQ	/GET THE JOB BEING SWAPPED OUT
	ERROR		/SET APPROPRIATE ERROR CODE
SWPER1,	 0
	JMP SWGOD1	/CLEAR ALL THE CONCERNED WORDS BEFORE LEAVING

	IFNZRO SWPRER-2	<GLITCH; *.-1>
SWERER=	C0002	/SWPRER
	IFNZRO SWPWER-3	<GLITCH; *.-1>
/SAVE JOB REGISTER
/THIS ROUTINE IS USED TO SAVE THE LEVEL 2 REGISTERS
/IN THE JOB DATA AREA.  AFTER SAVING THIS
/INFORMATION, JOB IS SET TO 0 TO INDICATE
/THAT NULJOB IS RUNNING
/CALL	SAVJOB
/	RETURN
/
/THE SAVE AREA FOR A JOB NOW LOOKS LIKE THIS:
/
/JOBREG
/	.................................................
/ +0	:			PC			:
/	:................................................
/ +1	:			AC			:
/	:...............................................:
/ +2	: M : L : G :   IOT COPY #  :<------ SC ------->:
/	:...:...:...:...:...:...:...:...:...:...:...:...:
/
/WHERE:	M = 1 (4000 BIT) IF EAE IS IN MODE 'B'
/	L = 1 (2000 BIT) IF LINK IS SET
/	G = 1 (1000 BIT) IF 'GT' FLAG IS SET

PTTIM0,
SAVJO0,	0
	TAD JOB
	SNA		/IS NULJOB RUNNING ALREADY?
	JMP SAVJO1	/YES - NOTHING TO SAVE
	AND C0600
	SZA CLA		/IS A PHANTOM RUNNING?
	JMP SAVJO3	/YES

	IFZERO MQREG-1 <
	GETJTW		/GET THE MQ-REGISTER POINTER
	 JOBEAE
	CLA MQA		/GET THE CONTENTS OF THE MQ
	DATFLD
	DCA I JOBSWA	/ & SAVE IT
	>
	CDF
	IFZERO EAE-20 <
		IFZERO CPU-2 <
	SKB		/SKIP IF MODE 'B' SET (ALSO CLOBBERS AC & MQ)
	SKP CLA		/MODE 'B' NOT SET
	CLA CLL CML RAR	/INDICATE MODE 'B' BY 4000
	SGT		/'GT' FLAG SET?
	SKP		/NO
	TAD C1000	/YES - SET THE BIT
		>
	SCA		/NOW GET THE SEQUENCE COUNT
	TAD L2SVLK	/ ADD IN THE LINK (2000 BIT)
	DCA L2SVLK	/ & SAVE ALL THE BITS
	>
	TAD CJOBDA
	GETJTA		/GET THE SAVE-AREA ADDRESS
	 JOBREG
	DCA PTTIM1
	BLT		/NOW SAVE THE REGISTERS
	 CDF
	 L2SV0	/ (LEVEL 2 SAVE)
	 DATFLD
PTTIM1,	 0	/ (JOB STATUS BLOCK SAVE)
	 -3	/3 WORDS - PC, AC, & LINK
SAVJO3,	TAD JOB
	AND C0037
	SNA CLA		/DO WE HAVE A JOB NUMBER?
	JMP SAVJO2	/NOT YET
	GETJTW		/YES - GET POINTER TO LOW-ORDER CPU TIME
	 JOBRTM
	CLA
	TAD QUATIM	/UPDATE HIS RUN TIME
	TAD JOBTIM	/-# TICKS HE DIDN'T USE
	SNA		/IF YOU WANT TO CHARGE HIM SOMETHING, CHANGE
	NOP		/ THIS TO 'IAC', YOU'LL CHARGE HIM 1 TICK FOR EACH FRACTION
	CLL
	DATFLD
	TAD I JOBSWA	/ACCUMULATE INTO RUNTIME
	DCA I JOBSWA	/SAVE THE NEW CUMULATIVE TIME
	SNL		/OVERFLOW INTO HIGH ORDER?
	JMP .+4		/NO
	ISZ JOBSWA	/YES - GET TO THE HIGH-ORDER TIME
	ISZ I JOBSWA	/ AND BUMP IT ONE UNIT
	NOP
	JMS I SAVJO4	/SET THE BIT IF IT WAS COMPUTE-BOUND
SAVJO2,	DCA JOB		/SIMULATE NULJOB
	DATFLD
	DCA I CJOBDA	/CLEAR POINTER TO CURRENT JOB DATA AREA
SAVJO1,	CDF
	JMP I SAVJO0	/AND EXIT.

SAVJO4,	COMBND
QUATIM,	-QUANT
/ROUTINE TO SET DEVICE TIMER IN SCHED
/CALLING SEQUENCE
/TAD ADDRESS OF PARAMETER LIST
/JMS PTTIM
/PARAMETER CONTAINS
/	ADDRESS IN SCHED TO STICK ISZ
/	ISZ INSTUCTION
/	ADDRESS OF INITIAL COUNT FOR DEVICE-COUNTER IS AT THIS ADD+1


PTTIM,	0
	DCA PTTIM1	/STORE THE ADDRESS OF THE PARAMETER
	TAD I PTTIM1	/ADDRESS OF ISZ
	ISZ PTTIM1
	DCA PTTIM0
	TAD I PTTIM1	/ISZ INSTRUCTION
	DCA I PTTIM0
	ISZ PTTIM1
	TAD I PTTIM1	/ADDRESS OF THE INITIAL COUNT
	DCA PTTIM0
	TAD I PTTIM0	/#OF TICKS
	ISZ PTTIM0	/ADDRESS+1 IN SCHED
	DCA I PTTIM0
	JMP I PTTIM	/RETURN

	IFZERO D680-2 <
KECHO,	ISZ I KECHOF	/ECHO SERVICE ALREADY SCHEDULED?
	DISMIS		/YES
	TAD .+2		/NO - SCHEDULE IT NOW
	DISMIS
	ECHO
KECHOF,	ECHOFL
	>
	PAGE

/COMBINED RESIDENT IOTS

UUOTBL,	40	/TELEPRINTER
	30	/KEYBOARD
	10	/READER
	20	/PUNCH
	660	/PRINTER
		IFZERO CDR-1 <
	630	/CARD READER
	670	/CARD READER
		>
	0

/UNCOMBINED RESIDENT IOTS

	6006	/SGT - SKIP IF 'GT' FLAG IS SET
	6603	/RFILE
	6605	/WFILE
	6200	/CKS - CHECK STATUS
	6405	/CLS - CLEAR STATUS

	6400	/KSB - SET KEYBOARD BREAK
	6401	/SBC - SET BUFFER CONTROL FLAGS
	6402	/DUP - DUPLEX TELETYPE CONSOLE
	6403	/UND - UNDUPLEX TTY
	6406	/SEGS - RETURN # FREE DISC SEGMENTS

	6411	/URT - USER RUN TIME
	6412	/TOD - TIME OF DAY
	6413	/RCR - RETURN CLOCK RATE
	6414	/DATE
	6415	/SYN - QUANTUM SYNCHRONIZATION
	6416	/STM - SET TIMER
	6417	/SRA - SET RESTART ADDRESS

	6420	/TSS - SKIP ON TS8
	6421	/USE - USER
	6422	/CON - USER CONSOL
	6423	/PEEK - LOOK IN MONITOR CORE

	6430	/SSW - SET SWITCH REGISTER
	6431	/SEA - SET ERROR ADDRESS

	6614	/SIZE
	6617	/ACT - ACCOUNT NUMBER

		IFZERO TC01-1 <
	6764	/DTXA - LOAD STATUS REGISTER A
	6771	/DTSF - SKIP ON DT FLAGS
	6772	/DTRB - READ STATUS REGISTER B
	6773	/DTSF DTRB - MICROCODED
		>
	0

/NON-RESIDENT IOTS


	6440	/ASD - ASSIGN DEVICE
	6442	/REL - RELEASE

	6602	/CLOS - CLOSE FILE
	6600	/REN - RENAME FILE
	6604	/PROT - PROTECT FILE
	6607	/CPASS - CHANGE USER'S PASSWORD
	6610	/CRF - CREATE FILE
	6611	/EXT - EXTEND FILE
	6612	/RED - REDUCE FILE
	6615	/LOGOUT
	6620	/BCLR - CLEAR MFD BILLING FIELDS
	0

/LONG NON-RESIDENT IOTS

	6601	/OPEN - OPEN FILE
	6606	/XOPEN - OPEN WITH EXCLUSIVE USE
	6613	/FINF
	0


/COMBINED RESIDENT IOT DISPATCH

UUODTB,	UTEL	/TELEPRINTER
	UKEY	/KEYBOARD
	UPTR	/READER
	UPTP	/PUNCH
	UPTP	/LPT SERVICE SAME AS PTP
		IFZERO CDR-1 <
	UCDR	/CARD READER
	UCDR1	/CARD READER
		>
	0

/UNCOMBINED RESIDENT IOT DISPATCH

	USGT
	UFILE
	UFILE
	UCKS
	UCLS
	UKSB
	USBC
	UDUP
	UUND
	USEGS
	UURT
	UTOD
	URCR
	UDATE
	USYN
	USTM
	USRA
	UTSS
	UUSE
	UCON
	UPEEK
	USSW
	USEA
	USIZE
	UACT
		IFZERO TC01-1 <
	UDTXA0
	UUOEX2
	UDTRB
	UDTRBS	
		>
	0

/-# ARGUMENTS FOR NON-RESIDENT IOTS

	0	/ASD
	0	/REL
	0	/CLOS
	-6	/REN
	0	/PROT
	-6	/CPASS
	-4	/CRF
	-4	/EXT
	-4	/RED
	0	/LOGOUT
	0	/BCLR
	0
UFILWC,	-6	/OPEN
	-6	/XOPEN
	-2	/FINF
	0
/RETURN CONTENT OF STATUS WORD IN AC
/CALL	TAD POINTER TO JOB STATUS ADDRESS
/	GETJTI
/	 RELATIVE ADDR OF WORD
/	RETURN (ADDRESS OF WORD IN JOBSWA)

GETJI0,	0
	CDF
	DCA JOBSWA	/SAVE POINTER TO JOB STATUS
	TAD I GETJI0	/GET POSITION IN LIST
	DCA .+3		/SAVE IT
	TAD JOBSWA	/NOW GET ADDRESS OF THIS ENTRY
	GETJTA
	 0
	DCA JOBSWA	/SAVE IT
	DATFLD
	TAD I JOBSWA	/GET CONTENTS OF THAT ADDRESS
	CDF
	ISZ GETJI0	/INDEX RETURN
	JMP I GETJI0
	PAGE
/TSS/8 CRASH-RECOVERY BOOTSTRAP
/WE JUST LOAD 'INIT' AND START IT.
/
/IN THE (VERY RARE) EVENT THE SYSTEM SHOULD CRASH OR (MORE LIKELY)
/A POWER OR HARDWARE FAILURE OCCURS, THIS ROUTINE MAY BE STARTED
/AT LOCATION 4200 IN FIELD 0.
RELOAD,	DCA RBOOT	/SAVE THE CRASH-ADDRESS
	SKP
RBOOT,	0		/ENTRY FOR AUTOMATIC RESTART
	NOP		/ (ROOM FOR POSSIBLE HLT)
BOOT,	CDF
	IFNZRO CPU-2	<IOF>
	IFZERO CPU-2	<CAF>
	CLA CLL CMA
	DCA I B7751	/SET THE CORE ADDRESS -1
	DCA I B7750	/ & THE WORD-COUNT
	TAD BTFLD	/GET THE 'INIT' FIELD

	IFZERO RF08 <
	DIML
	CLA STL RTL
	DXAL		/'INIT' IS ON TRACK 2
	>
	IFZERO RF08-40 <
	DEAL
	CLA
	NOP		/FOR SIZE ONLY
	>
	DMAR		/READ THE TRACK
	DFSC		/ & WAIT
	JMP .-1
	TAD RBOOT
	CIF CDF INFLD
	JMP I .+1	/NOW START 'INIT'
	AUTOST

B7751,	7751
B7750,	7750
	IFZERO RF08 <
BTFLD,	INFLD
	>
	IFZERO RF08-40 <
BTFLD,	200+INFLD	/FIELD & TRACK
	>
/INCLUSIVE OR
/CALL	TAD ADDRESS OF WORD TO SET
/	CDF+(FIELD)	/FIELD WHERE DATA-WORD RESIDES
/	IOR
/	 BITS TO SET
/	RETURN

IOR0,	0
	SNA		/IS THIS A RATIONAL ADDRESS?
	REBOOT		/NO - ERROR *****
	DCA IOR1	/SAVE ADDRESS TO SET
	RDF		/FIELD TO SET IT IN
	TAD .+2		/COMPUTE FIELD SELECT - FOR THAT FIELD
	DCA .+3		/SAVE IT
UDFCDF,	CDF
	TAD I IOR0	/GET BITS TO SET
	0		/SET FIELD AGAIN
	DCA IOR2	/SAVE THEM
	TAD IOR2
	CMA
	AND I IOR1	/CLEAR THE BITS IF ALREADY SET
	TAD IOR2	/NOW SET THEM
	DCA I IOR1	/SAVE NEW VALUE
	ISZ IOR0	/SKIP ARGUMENT IN CALL
	JMP I IOR0	/RETURN

IOR1,	0
/CHECK SIZE OF TTY BUFFER
/CALLING SEQUENCE:
/	TAD (ADDRESS OF EMPTY POINTER)
/	JMS BUFSIZ
/	-#BLOCKS TO CHECK FOR
/	RETURN (BUFFER LESS THAN .-1)
/	RETURN (BUFFER GREATER THAN OR EQUAL TO .-2)

IOR2,
BUFSIZ,	0
	DCA BUFSI1	/POINTER TO EMPTY COUNTER
	CDF
	TAD I BUFSIZ	/GET COUNT TO CHECK FOR
	DCA BUFSI2	/COUNTER
	ISZ BUFSIZ	/INCREMENT RETURN PAST ARGUMENT
	DATFLD
	TAD I BUFSI1	/GET ADDRESS OF FIRST BUFFER
	SNA
	JMP I BUFSIZ	/CHAIN IS SHORTER THAN COUNT
	DCA BUFSI1	/SAVE NEW PTIZ
	ISZ BUFSI2	/STILL ROOM LEFT
	JMP .-5		/YES, KEEP LOOKING
	ISZ BUFSIZ	/NO, INDEX TO "FULL" RETURN
	JMP I BUFSIZ	/EXIT

BUFSI1=	IOR0		/POINTER
BUFSI2=	IOR1		/COUNTER
/THIS CODE RE-STARTS THE CLOCK & ALLOWS THE CONTINUATION
/OF A SYSTEM THAT WAS STOPPED IN 'NULJOB'.

DEBUG,
	IFZERO D680 <
		IFZERO CPU-1 <
	CLA CLL CMA
	CCF CLB		/SET PDP-8 CLOCK COUNT
		>
		IFNZRO CPU-3 <
	CECI		/RE-ENABLE THE PDP-8 CLOCK
		>
		IFZERO CPU-3 <
	TAD PT12TM	/GET THE NUMBER OF TICKS PER OVERFLOW
	CLAB		/SEND TO THE CLOCK CONTROLLER
	CLA
	TAD PT12CM	/GET THE MAJOR CLOCK COUNT RATE
	CLLR		/AND SEND IT TO THE CONTROLLER
	CLA
	TAD PT12IN	/SET UP INTERRUPTS AND SO ON.
	CLEN
	CLSA		/ & START THE CLOCK GOING
	CLA CMA		/SET TO ENABLE ALL SETS
	MTON
	CLA IAC		/ AND ALSO THE INTERRUPTS
	MINT		/ FOR THE FANTASTIC DC02
	CLA
		>
	>
	IFZERO D680-2 <
	TT8ON		/TURN ON THE DC08 CLOCK
	>
	IFZERO D689-4 <
	EDF		/RE-ENABLE THE DATA PHONES
	>

SCHNUL,	TAD C0100	/RUN NULL JOB IN USER MODE.
	DCA L2SF	/FIELD 0; USER MODE
	TAD SCHNJA
	DCA L2SV0
	EXIT		/OFF TO NULL JOB

SCHNJA,	NULJOB

	IFZERO CPU-3 <
	DECIMAL
PT12TM,	-50		/50 MILLISECONDS PER INTERUPT
	OCTAL
PT12CM,	4100		/1 M.S. PER CLOCK TIC.
PT12IN,	300
	>
	IFZERO D680-2 <
/PSEUDO OPERATIONS
/SKIP IF OUTPUT IS FREE AND TRANSMIT CHARACTER AT TTCHAR, OTHERWISE DONT SKIP
/LINE NUMBER MUST BE IN AC.  24US MIN. 42US MAX.
T8OUTS,	0
	AND T8K10             /177
	TAD T8SL		/-STARTING LINE #
	TAD T8K36		/OUTPUT BUFFER ADDR
	DCA T8WA		/WORK AREA
	TAD I T8WA		/OUTPUT CHARACTER
	SZA CLA			/SKIP IF FREE
	JMP I T8OUTS		/EXIT
	TAD TTCHAR		/PICK UP CHARACTER
	AND T8K11		/8 BITS ONLY
	TAD T8K12		/1400 FOR STOP CODE
	CLL RAL			/CREATE START CODE
	DCA I T8WA		/STORE CHARACTER IN TABLE
	ISZ T8OUTS		/INDEX EXIT
	JMP I T8OUTS		/EXIT
T8K10,	177			/FOR LINE NUMBER
T8WA,	0			/WORK AREA
T8K11=	C0377	/FOR EIGHT BIT CODE
T8K12,	1400			/FOR STOP CODE
/SKIP IF CHARACTER AVAILABLE AND RETURN WITH LINE NO. IN AC, CHAR AT TTCHAR
/OTHERWISE DO NOT SKIP. 15 US MIN, 48 US MAX, 37.5US NORMAL IF READY
T8INS,	0
	IOF
	CLA CMA		/SET AC TO -1 FOR TAD
	TAD T8INFL	/INPUT FLAG COUNTER
	SPA		/SOMETHING AVAILABLE
	JMP T8INON		/EXIT
	DCA T8INFL	/RESTORE FLAG COUNTER
	ISZ T8CNT3	/END OF BUFFER? STARTS AT -N-1
	JMP .+5		/GET CHARACTER
	TAD T8NL	/-NUMBER OF LINES
	DCA T8CNT3	/RESET COUNTER
	TAD T8BFK	/BUFFER ADDRESS-1
	DCA T8AX1	/RESET ADDRESS
	TAD I T8AX1	/PICK UP CHARATER

	IFZERO TTYEVEN-1 <
	AND T8K10
	TAD C0200	/FORCE BIT 8 TO BE A 1
	>
	IFZERO TTYEVEN <
	AND C0377	/ONLY CONSIDER LOW ORDER 8 BITS
	>
	DCA TTCHAR	/STORE CHARACTER
	TAD I T8AX1	/PICK UP LINE NUMBER
	ISZ T8INS		/INDEX EXIT
	SKP
T8INON,	CLA
	ION
	JMP I T8INS	/EXIT
	>
/ROUTINE TO HANDLE THE 'SGT' IOT - PRETTY SIMPLE.
USGT,	SGT		/SKIP IF 'GT' IS SET
	UUOEXT		/NO - JUST EXIT
	JMP I .+1	/YES - INCRE. USER'S PC
UUOSKP,	UUOEX2

/CODE TO HANDLE THE 'TSS' IOT.
	VERNUM
UTSS,	TAD .-1
	DCA L2SA	/RETURN THE MONITOR VERSION #
	JMP I UUOSKP	/ AND SIMULATE SKIP

/ROUTINE TO SET UP SUBROUTINE 'UDF'.
UDFSET,	0
	TAD L2SF	/GET THE USER'S FIELD
	AND C0070
	TAD UDFCDF	/ & FORM A CDF INSTR.
	DCA UUDF
	JMP I UDFSET
/ROUTINE TO SAVE MACHINE STATUS WHEN USER EXECUTES IOT
/WE MUST CHECK USER IOT FLAG BEFORE ANYTHING ELSE, EVEN CLOCK FLAG
/IF WE DON'T, AND CLOCK INTERRRUPTS WITHIN 8 MICROSECONDS AFTER USER
/EXECUTES IOT, THEN WE WOULD TRIP ON CLOCK FLAG, AND NOT BE ABLE TO
/FIGURE OUT WHAT IOT THE USER EXECUTED.  WHAT'S MORE, WE WOULD PROBABLY
/DISMIS BACK TO THE USER PROGRAM IN EXEC MODE.  

UUO0,	DCA L2SA	/WE MUST'VE BEEN IN USER MODE WHEN INTERRUPTED
	RTR		/SAVE LINK
	DCA L2SVLK
	TAD 0
	DCA L2SV0	/SAVE PC
	RIB
	DCA L2SF	/SAVE FIELDS AND MODE
	CIOT		/CLEAR FLAG

	IFZERO CPU-3 <
	TAD L2SF	/REGET THE FIELD BITS.
	AND C0037	/CHOP OFF THE USER BIT.
	SNA CLA		/WAS IT FROM NULL JOB?
	JMP NULUUO	/YES - FUDGE IT
	>
	ION
	JMP I .+1	/NOW GO RUN UUO SERVICE
	UUO

	IFZERO CPU-3 <
NULUUO,	CLA CMA		/UUO IS FROM NULJOB. BACK UP PC.
	TAD 0
	DCA 0		/PLACE IT AWAY.
	JMP I 0		/AND GO TO IT. NUL JOB MUST TURN THEM BACK ON.

DISIDL,	CLA		/CLEAR THE AC TO INDICATE FIRST TIME THROUGH
DISTOR,	DCA DISIDG	/SAVE AC FOR A SECOND
	IOF		/TURN OFF INTERUPTS
	CDF CIF 10	/SET TO FIELD 1
	TAD DISIDG	/GET THE INDICATORS IN THE AC.
	JMS I DISIDM	/GO THERE NOW
	UFN		/SET THE USER FLOP
	ION		/TURN THEM BACK ON
	JMP DISTOR	/GO AND LOOP AGAIN

DISIDG,	0
DISIDM,	PDPIDE
	>
	IFNZRO READFI-4-.&4000	<GLITCH; *.-1>
	*READFI-4
	L2EXIT
DSUEXT,	TAD .-1
	DCA EXITA	/RESTORE THE LEVEL-2 EXIT
	JMP .+3		/JOB # ALREADY IN 'RDFJOB'
READFI,	TAD SIREG
	DCA RDFJOB
	SAVJOB
	TAD RDFJOB	/FIND RESIDENT FIELD FOR THIS JOB
	CORE
	 FIP+SI+37	/ANY FIELD WITH THIS JOB IN IT IS OK
	REBOOT		/IF IT'S NOT THERE WE'RE SCREWED
	DCA L2SF	/RESTORE FOR THIS JOB
	TAD RDFJOB
	RESJOB		/RESTORE LEVEL TWO FOR THIS JOB
	GETJTW		/GET ADDRESS OF FILE PARAMETER BLOCK
	 JOBLNK
	DATFLD
	JMP I .+1	/ AND OFF TO FILE HANDLER
	SIFILE
/QUEUE DISC REQUEST
/CALL	TAD ADDRESS OF TRANSFER BLOCK
/	JMS DSQUE
/	RETURN

	IFNZRO FILPIF-2	<GLITCH; *.-1>
DSQFLD=	C0002	/FILPIF

RDFJOB,
DSQUE,	0
	DCA DSQUE1	/SAVE ADDRESS OF PARAMETER BLOCK
	TAD DSQUE1	/NOW GET POINTER TO WORD WITH FIELD & FILE DATA
	TAD DSQFLD
	DCA DSQUE2	/SAVE POINTER
	DATFLD
	TAD I DSQUE2	/GET FIELD # (BITS 7-9) AND FILE # (BITS 10-11)
	AND C0037	/USE THIS VALUE AS DSUTBL INDEX
	TAD DSUTBA
	DCA DSQUE2	/SAVE POINTER TO DSUTBL
	TAD DSQUE1	/GET PARAMETER ADDRESS
	DCA I DSQUE2	/SAVE IN DSUTBL
	CDF		/AND EXIT
	JMP I DSQUE

	IFNZRO JCOMBD-1000	<GLITCH; *.-1>
DSQUE1,
COMBND,	0
	TAD JOBTIM
	SZA CLA		/ANY PART OF HIS TIME-SLICE LEFT?
	JMP I COMBND	/YES - SO HE'S NOT COMPUTE-BOUND NOW
	GETJTW		/NO - GET HIS JOB STATUS-WORD
	 JOBSTS
	TAD C1000	/ AND SET THE 'JCOMBD' BIT
	DATFLD
	DCA I JOBSWA
	JMP I COMBND	/THEN RETURN
/RETURN CONTENT OF JOB STATUS FOR CURRENT JOB
/CALL:	GETJTW
/	 RELATIVE ADDRESS OF WORD
/	RETURN (VALUE IN AC, ADDRESS IN 'JOBSWA')

DSQUE2,
GETJW0,	0
	CDF
	TAD I GETJW0	/GET THE RELATIVE ADDRESS
	DCA .+3		/ AND SAVE IT
	TAD CJOBDA
	GETJTI		/NOW PICK UP THE WORD
	 0
	ISZ GETJW0	/SKIP PAST THE PARAMETER
	JMP I GETJW0	/ AND RETURN

/LEVEL-2 TERMINATION CODE FOR THE HIGH-SPEED PUNCH.
/ENTERED AT PTPL2 IF BUFFER IS TO BE RE-INITIALIZED
/OR PTPL2+1 IF NOT.
PTPL2,	JMS I PTP2IN	/RE-INITIALIZE THE BUFFER POINTERS
	TAD PTPFL2	/ (LINK=0 TO RETURN THOUGH 'EXIT')
	JMS I PT2STR	/TURN ON PUNCH FLAG & EXIT
	 DEVTBE+1

PTPFL2,	JSPTP
PTP2IN,	PTPINI
PT2STR,	PTSTAR
/RESTORE INTERRUPTED STATE
/WE GET HERE WHEN ALL THE ACTIVITY IN THE LEVEL-2 QUEUE
/HAS BEEN COMPLETED. WE RESET THE QUEUE POINTERS & RESTART.

L2QTA,	L2QTB-1
L2SFA,	L2SF
	IFNZRO DSI-1000	<GLITCH; *.-1>
L2XCT1=	C1000	/DSI
L2XCT2,	CTRLC
L2XNOP,	NOP	/EXIT IN EXEC MODE
L2XUFN,	UFN	/USER MODE

L2EX1,	TAD L2QTA	/RESET EMPTY POINTER TO L2QUE
	DCA L2QE
	TAD L2QTA	/RESET FILL POINTER TO L2QUE
	DCA L2Q
	TAD L2SFA
RESTOR,	DCA WS0		/POINTER TO SAVED INFO
	TAD I WS0	/SAVED FIELDS AND STATE
	DCA 0		/RESTORE FIELDS AND MODE
	TAD 0
	AND C0070	/GET INSTRUCTION FIELD
	TAD C6203
	DCA RCIF	/CIF FOR PROPER FIELD
	TAD 0
	CLL RTL
	RAL
	AND C0070	/CDF FOR RETURN
	TAD C6201	/NOT NECESSARY EQUAL TO INSTRUCTION FIELD
	DCA RCDF
	TAD 0
	AND C0100	/USER PROGRAM, FIP OR SI?
	SNA CLA		/USER MODE OR EXEC MODE?
	JMP L2EX2	/EXEC MODE
	TAD L2XUFN
	DCA RUFF	/SET USER-MODE FLAG UPON EXIT
	TAD JOB
	SNA		/IS THIS A REAL JOB?
	JMP L2EX3	/NO - MUST BE NULJOB
	TTYUSE		/YES - GET HIS INPUT DDB
	 0
	DCA WS1
	DATFLD
	TAD I WS1	/PICK UP HIS DDB STATUS-BITS
	AND L2XCT1
	SZA CLA		/IS HE IN 'SI' MODE?
	JMP L2EX3	/YES - THEN ANY CTRL/C WOULD BE 'SI'S
	TAD I WS1
	AND L2XCT2
	SNA		/NO - WAS CTRL/C TYPED?
	JMP L2EX3	/NO
	CMA
	AND I WS1	/YES - CLEAR THE FLAG
	DCA I WS1
	GETJTW		/GET HIS PROGRAM-RESTART ADDRESS
	 JOBSRA
	DCA 0
	CLA CLL		/HIS AC & LINK GET CLEARED
	JMP RCIF	/ & HE'S RESTARTED
L2EX2,	TAD L2XNOP
	DCA RUFF	/LEAVE USER-MODE FLAG CLEARED FOR EXEC STUFF
L2EX3,
C6201,	CDF
	ISZ WS0
	TAD I WS0	/PC
	DCA 0
	ISZ WS0
	TAD I WS0	/LINK
	CLL RTL
	ISZ WS0
	CLA
	TAD I WS0	/AC
RCIF,	0
RCDF,	0
RUFF,	0		/'UFN' IF USER MODE, 'NOP' IF EXEC MODE
	ION
	JMP I 0		/BACK TO INTERRUPTED PROGRAM
	PAGE
/RETURN NUMBER OF NEXT RESIDENT RUNNABLE JOB IN AC
/CALL	JMS NXTCOR
/	RETURN WITH JOB # IN AC
/
/	THIS WILL RUN A "ROUND ROBIN" OF CORE RESIDENT JOBS

	IFNZRO FIX-100	<GLITCH; *.-1>
NXTCOR,	0
	TAD I NXTLIM	/GET (-) THE NUMBER OF USER FIELDS
	DCA NXTCNT
	TAD FANCOR
	DCA NXTST	/SET THE 'CORTBL' POINTER
NXTCO3,	TAD I NXTST	/ AND PICK UP THE CONTENT OF THIS FIELD
	AND C0100	/HAS IT JUST FINISHED A DISC I/O?
	SNA 
	JMP NXTCO4	/NO TEST THE NEXT FIELD
	CMA
	AND I NXTST	/REMOVE THE FLAG
	DCA I NXTST
	TAD I NXTST	/YES, FIND THE JOB#
	AND C0037	/JUST JOB #
	RUNABL		/IS IT RUNNABLE?
	JMP NXTCO4	/NO, TRY NEXT FIELD
	TAD I NXTST	/YES - RETURN WITH 'CORTBL' ENTRY
	JMP I NXTCO5
NXTCO4,	ISZ NXTST	/INCREMENT THE FIELD POINTER
	ISZ NXTCNT	/ANY MORE FIELDS LEFT?
	JMP NXTCO3	/YES - TRY THEM
	TAD I NXTLIM	/GET THE NUMBER OF FIELDS AGAIN
	DCA NXTCNT
NXTCO2,	ISZ NXTCOP	/INCREMENT THE 'CORTBL' POINTER
	TAD NXTCOP
	TAD I NXTEND
	SZA CLA		/ARE WE PAST THE END OF THE TABLE?
	JMP .+3		/NOT YET
	TAD FANCOR	/YES - START AGAIN AT THE FRONT
	DCA NXTCOP
	TAD I NXTCOP	/NOW GET THE NEXT ENTRY
	AND NXTCHK
	SZA CLA		/IS IT EITHER BEING SWAPPED OR A PHANTOM?
	JMP NXTCO1	/YES; SO IT'S NOT  A USEFUL FIELD NOW
	TAD I NXTCOP
	AND C0037	/WHAT JOB
	SNA		/IS IT A JOB?
	JMP NXTCO1	/NOPE
	RUNABL
	JMP NXTCO1	/NOT RUNNABLE
	TAD I NXTCOP	/IT'S A GOOD ONE
	JMP I NXTCOR

NXTCO1,	ISZ NXTCNT	/HAVE WE CHECKED ALL ENTRIES?
	JMP NXTCO2	/NO
	JMP I NXTCOR	/YES; NOTHING RUNABLE EXCEPT NULL JOB

NXTCOP,	CORTBL		/ROUND ROBIN CORTBL POINTER
NXTEND,	CORTBE	/END OF CORTBL (SET BY 'INIT')
NXTLIM,	CORCNT	/NUMBER OF USER FIELDS (SET BY 'INIT')
NXTST,	0
NXTCO5,	SCHEI2
NXTCHK,	FSWP+FIP+SI
UHALSA,	L2SA

UHALT,	TAD UUOCAL	/IS IT A 7404?
	AND C0004
	SNA CLA		/OSR?
	JMP UHALT1	/NO
	GETJTW		/YES, GET CURRENT VALUE OF SWITCHES
	 JOBSWR
	DCA UHALT2	/OR IT INTO AC
	TAD UHALSA	/WHICH IS RIDICULOUS, SINCE OSR
	IOR		/IS UNIVERSALLY CODED AS LAS, AND
NXTCNT,
UHALT2,	 0		/A SIMPLE "DCA L2SA" WOULD DO
UHALT1,	TAD UUOCAL	/NOW SEE IF IT WAS MICROCODED
	AND C0002	/HALT?
	SNA CLA
	UUOEXT		/NO
	GETJTW		/YES, CLEAR HIS RUN BIT
	 JOBSTS
	AND UHBITS
	TAD UJSHLT	/ & SET THE 'HLT' BIT
	DATFLD
	DCA I JOBSWA
	ISZ COMCNT	/INDICATE THAT 'SI' HAS WORK TO DO
	TAD JOB
	TTYUSE		/NOW GET HIS KEYBOARD NUMBER
	 0		/ (INPUT SIDE)
	DCA UHALT2
	TAD UHALT2
	DATFLD
	JMS I USBC2	/IS HE ALREADY IN SI MODE?
	WAIT		/YES
	TAD UHALT2
	JMS I USBCLR	/NO - CLEAR HIS INPUT BUFFER
	TAD UHALT2
	DATFLD
	IOR		/NOW SET THE 'SI' BIT
	 DSI
	WAIT

UHBITS,	-JSRUN-JSHLT-1
UJSHLT,	JSHLT
/SET BUFFER CONTROL FLAGS

USBCLR,	CLRBUF
USBFLG,	CLSTR1
USBTEL,	JSTEL
	IFNZRO JSDEL-100	<GLITCH; *.-1>
USBDEL=	C0100	/JSDEL


USBC,	TAD L2SA	/WHAT IS REQUESTED?
	SMA CLA		/CLEAR OUTPUT BUFFER?
	JMP USBC1	/NO
	TAD JOB		/YES. FIND USER OUTPUT BUFFER
	TTYUSE
	 1		/ (OUTPUT SIDE)
	JMS I USBCLR	/CLEAR OUTPUT BUFFER
	TAD USBTEL
	JMS I USBFLG	/CLEAR TELEPRINTER FLAG
USBC1,	TAD L2SA
	CLL RAL
	SMA CLA		/CLEAR INPUT BUFFER?
	JMP USBC3		/NO
	TAD JOB		/GET ADDRESS OF INPUT DDB
	TTYUSE
	 0		/ (INPUT SIDE)
	DCA UHALT2		/STORE THE INPUT DDB ADDRESS
	TAD UHALT2
	DATFLD
	JMS I USBC2	/IS DDB IN SI MODE?
	JMP USBC3	/YES LEAVE THE BUFFERS ALONE
	TAD UHALT2	/INPUT DDB ADDRESS
	JMS I USBCLR	/CLEAR INPUT BUFFER
	TAD USBDEL
	JMS I USBFLG	/CLEAR FLAG

USBC3,	DCA L2SA	/CLEAR HIS AC
	UUOEXT
USBC2,	CONCB
	PAGE
	IFNZRO .-4200	<GLITCH; *.-1>

/STANDARD BOOTSTRAP AND RESTART ADDRESSES

	JMP I .+2	/INIT BOOTSTRAP
	JMP I .+2	/RESTART ADDRESS
	BOOT
	DEBUG
FILERC,	0		/ROUTINE TO RECOVER FROM DISC ERRORS
FILUSA,	0		/AND SET ERROR CODES FOR USER
FILEWC,	0		/ERROR CODES ARE:
FILER1=	WS2		/	1  PARITY
			/	2  END OF FILE
			/	3  FILE NOT OPEN
			/	4  PROTECTION VIOLATION
FJSF3,	-JSF3-1
	IFNZRO FILPCA-4	<GLITCH; *.-1>
FILECA=	C0004	/FILPCA
	IFNZRO FILPCT-7	<GLITCH; *.-1>
FILECT=	C0007	/FILPCT
	IFNZRO FILPIF-2	<GLITCH; *.-1>
FILEIF=	C0002	/FILPIF
	IFNZRO FILWC-6	<GLITCH; *.-1>
FILWCA=	C0006	/FILWC
F0005,	5
C3777,	3777
C6000,	6000
FILERR,	0
	DCA FILERC	/ERROR CODE
	CDF
	CLA CLL CMA RAL	/AC:=-2
	TAD FILERC	/ERROR CODE - GT.2?
	SPA SNA CLA	/PROTECTED OR NOT OPEN?
	JMP FILER2	/NO
	GETJTW		/GET ADDRESS OF PARAMETER BLOCK
	 JOBLNK
	RETBLK		/RETURN IT TO FREE CORE
	CLA
	TAD L2SA	/GET POINTER TO PARAMETERS IN USER AREA
	TAD F0005
	DCA FILERR	/POINTS TO SIXTH USER PARAMETER (ERROR CODE)
	TAD FILERC	/GET ERROR
	UDF		/SELECT USER FIELD
	DCA I FILERR	/PASS ERROR TO USER
	CDF
	DCA L2SA	/CLEAR HIS AC
	UUOEXT		/AND BACK TO HIM

FILER2,	TAD I FILERR	/END OF FILE OR PARITY ERROR...
	TAD FILEIF	/GET ADDRESS OF FILE PARAMETER BLOCK
	DCA FILER5	/POINTS TO WORD 3 OF BLOCK
	DATFLD
	TAD I FILER5	/WAS FILE CALL ORIGINATED BY SI?
	AND C6000	/BITS 0-1 WILL BE SET IF SO...
	SNA CLA
	JMP FILER4	/NO - IT CAME FROM USER PROGRAM
	TAD I FILER5	/YES - GET FIELD # FOR TRANSFER
	RTR
	AND C0007	/MASK OUT FILE # BITS
	TAD CORTBA	/INDEX INTO CORTBL
	DCA FILUSA	/SAVE POINTER TO CORTBL ENTRY FOR THIS TRANSFER
	CDF
	TAD I FILUSA	/GET CORTBL ENTRY
	AND C0037	/EXTRACT JOB #
	DCA FILUSA	/SAVE JOB #
	TAD FILERC
	SZA		/WAS THERE ANY ERROR AT ALL?
	TAD C7776
	SNA CLA		/YES - WAS IT OTHER THAN AN END-OF-FILE?
	JMP FILER6	/NO - WE'RE ALMOST DONE THEN
	TAD FILUSA	/MUST BE PARITY ERROR - SET THE ERROR CODE
	ERROR
	 DSKERR
FILER7,	TAD FILUSA	/JOB #
	TAD JOBTBA
	GETJTI		/GET CONTENTS OF WAIT MASK
	 JOBWMK
	AND FJSF3	/CLEAR FILE 3 WAIT BIT
	DATFLD
	DCA I JOBSWA	/SAVE WAIT MASK
FILER3,	ISZ FILERR	/INDEX PAST CALLING ARGUMENT
	CDF
	JMP I FILERR	/AND BACK

/WE COME HERE IF THE TRANSFER WAS INITIATED BY 'SI' AND
/ENDED WITH AN END-OF-FILE ERROR OR NO ERROR AT ALL.
FILER6,	DATFLD		/GET WORD 3 OF PARAMETER BLOCK
	TAD I FILER5	/WAS SI COMMAND RUN OR LOAD/SAVE?
	SPA CLA
	JMP FILER8	/RUN - LET JOB CONTINUE
	CDF		/LOAD/SAVE - NOW STOP JOB
	TAD FILUSA
	TAD JOBTBA
	GETJTI		/GET CONTENTS OF STR0
	 JOBSTS
	AND C3777	/CLEAR RUN BIT
	DATFLD
	DCA I JOBSWA	/SAVE NEW STR0
FILER8,	CDF
	JMP FILER7	/GO CLEAR WAIT MASK & BACK

FILER4,	TAD I FILER5	/UPDATE USER CONTROL TO INDICATE ERROR CODE
	RAL		/SHIFT FIELD # INTO BITS 6-8
	AND C0070	/SAVE IT
	TAD FILCDF	/GENERATE "UDF"
	DCA FILER5	/USER FIELD SELECT
FILCDF,	CDF
	TAD I FILERR	/PARAMETER BLOCK ADDRESS
	DCA FILEWC	/SAVE IT
	TAD FILEWC
	DATFLD
	TAD FILECA
	DCA FILER1	/POINTS TO CORE ADDRESS IN PARAMETER BLOCK
	TAD I FILER1	/GET CORE ADDRESS
	DCA FILER1	/SAVE IT
	TAD FILEWC	/START OF PARAMETERS
	TAD FILECT	/+7
	DCA FILUSA	/POINTS TO PTR TO FILE CONTROL
	TAD I FILUSA	/GET ADDRESS OF FILE CONTROL
	TAD FILWCA	/POINTS TO WORD COUNT IN FILE CONTROL
	DCA FILEWC	/SAVE IT
	TAD FILEWC
	IAC
	DCA FILUSA	/POINTS TO POINTER TO USER PARAMETERS
	TAD I FILUSA	/GET POINTER TO USER ARGUMENTS
	DCA FILUSA	/SAVE
	TAD I FILEWC	/GET WORD COUNT TO GO FROM CONTROL BLOCK
FILER5,	0		/SELECT USER FIELD
	DCA I FILUSA	/SAVE IN USER AREA
	ISZ FILUSA	/POINTS TO WORD 4 OF USER ARGUMENTS
	TAD FILER1	/GET LATEST CORE XFER ADDRESS
	DCA I FILUSA	/SAVE FOR USER
	ISZ FILUSA
	ISZ FILUSA	/POINTS TO WORD 6 (ERROR WORD)
	TAD FILERC	/GET ERROR CODE
	DCA I FILUSA	/PASS ON TO USER
	JMP FILER3	/AND BACK
	IFNZRO JSTIME-4000	<GLITCH; *.-1>
DOXSTM,	TAD C7776	/WAIT 2 SECONDS TO TRY TO FIX I/O ERROR
DOUSTM,	DCA WS0		/SAVE - # UNITS OF TIME
	TAD JOB		/SET CLKTBL ENTRY FOR THIS JOB
	TAD CLKTBA
	DCA WS1		/POINTS TO THIS JOB'S ENTRY
	TAD WS0
	DATFLD
	DCA I WS1	/SET TABLE ENTRY
	STL RAR		/SET AC=JSTIME
	UUOEXT		/EXIT AND WAIT

CLKTBA,	CLKTBL	/JOB TIMER TABLE ADDRESS
	PAGE

/RFILE AND WFILE IOTS

UFILE,	TAD L2SF	/TRYING TO SWAP THIS FIELD?
	AND C0007
	CIA
	TAD FORCE	/FIELD # BEING SWAPPED
	SNA CLA
	REDO		/YES - DON'T DO IOT NOW
	TAD UFILWA	/NO. GET USER PARAMETERS
	JMS I UFPARM	/AND MOVE TO PARAMETER BLOCK
	TAD I UFLNKA	/ADDRESS OF PARAMETER BLOCK
	TAD UFIPIF
	DCA UFPARA	/POINTS TO WORD 3 OF BLOCK
	DATFLD
	TAD I UFPARA	/CLEAR ALL BUT FILE # IN BLOCK
	AND C0003
	DCA I UFPARA	/SAVE IT
	TAD L2SA	/ADDRESS OF USER PARAMETERS
	TAD UFIPWC	/+2
SIFIL1,	DCA UFILE1	/POINTS TO WORD COUNT IN USER AREA
	TAD I UFPARA	/FILE #
	AND C0003
	TAD UFJF0
	DCA UFJOBF	/RELATIVE ADDR OF FILE POINTER FOR THIS FILE
	GETJTW
UFJOBF,	 0		/POINTER TO FILE CONTROL INFO
	SNA
	JMP UFILER+1	/FILE NOT OPEN
	DCA UFJOBF	/SAVE POINTER TO FILE CONTROL
	DATFLD
	TAD I UFPARA	/FILE #
	JMS I UFIGJF	/GENERATE CORRESPONDING FILE BIT IN STR1
	DCA UFIJSF	/FILE STATUS FLAG
	TAD L2SF	/USER'S FIELD #
	AND C0007
	CLL RTL		/*4
	DCA JOBSWA	/SAVE
	TAD I UFPARA	/GET FILE # + ORIGINATING STATUS INFO.
	AND C7743	/CLEAR FIELD #
	TAD JOBSWA	/SET FIELD #
	DCA I UFPARA	/SAVE IN PARAMETERS
	TAD UFJOBF	/SAVE GLOBAL PARAMETERS
	IAC		/POINTS TO WORD 2 OF CONTROL BLOCK
	DCA AXS1	/CONTROL INDEX
	CLL CLA CMA RTL	/AC:=-3
	TAD UFPARA
	DCA AXS2	/PARAMETER INDEX POINTS TO START OF PARAMETERS-1
	TAD I AXS2	/WRITE AND PROTECTED?
	AND I AXS1
	SZA CLA
	JMP UFILER	/YES - ERROR
	TAD AXS2	/NO. SET FILPAR = START OF PARAMETER BLOCK
	DCA I AXS1
	TAD I AXS2	/DISC EXTENSION FROM PARAMETERS
	DCA I AXS1	/TO CONTROL BLOCK
	ISZ AXS2	/SKIP FIELD
	TAD I AXS2	/SAVE WC
	DCA JOBSWA
	ISZ AXS2	/SKIP CORE ADDRESS FOR NOW
	TAD I AXS2	/DISC ADDRESS
	DCA I AXS1	/TO CONTROL BLOCK
	TAD UFIRET	/RETURN ADDRESS
	DCA I AXS2	/TO PARAMETER BLOCK
	TAD UFJOBF	/POINTER TO FILE CONTROL
	DCA I AXS2	/TO PARAMETER BLOCK
	TAD JOBSWA	/WORD COUNT
	DCA I AXS1	/TO CONTROL BLOCK
	TAD UFILE1	/POINTS TO WC IN USER AREA
	SNA		/IS THIS AN SI REQUEST?
	JMP .+3		/YES
	DCA I AXS1	/NO, SAVE POINTER TO WC IN CONTROL BLOCK
	DCA L2SA	/CLEAR USER AC
	TAD UFJOBF	/POINTER TO CONTROL BLOCK
	TAD UFPAR2	/+3
	DCA UFILPA	/POINTS TO POINTER IN CONTROL BLOCK POINTING TO PARAM. BLOCK.
	TAD UFJOBF	/POINTS TO FILE CONTROL
	JMS I UFILIX	/GET SEGMENT INDEX
	JMP UFILE4	/NOT IN CORE - DO A WINDOW TURN
	JMP UFILE2	/NON-EXISTENT DISC ADDRESS
	JMS I UFICTB	/OK. SETUP TRANSFER BLOCK - POINTER TO SEGMENT # IN AC
UFILPA,	0		/POINTER TO FILPAR
	TAD I UFILPA	/ADDRESS OF PARAMETERS
	JMS I UFIQUE	/QUEUE THE REQUEST IN DSUTBL
	ISZ DSBUSY	/DISC BUSY?
	SKP		/YES
	JMS I FIUSER	/NO. START TRANSFER
	TAD UFIJSF	/CLEAR FILE STATUS BIT
	UUOEXT		/EXIT

SIFILE,	TAD UFIPIF
	DCA UFPARA	/POINTS TO FILE # IN PARAMETERS
	JMP SIFIL1	/REST IS SAME AS USER PROGRAMS

UFILE2,	GETJTW		/NON EXISTANT DISC ADDRESS
	 JOBLNK		/GET ADDRESS OF PARAMETERS
	DCA UFILE1	/SAVE IT
	JMP .+3
UFILER,	IAC		/PROTECTED
	IAC		/NOT OPEN
	TAD C0002	/EOF
	JMS I UFERR	/FILE ERROR ROUTINE
UFILE1,	0		/POINTS TO PARAMETER BLOCK
	TAD UFILE1
	RETBLK		/RETURN PARA. BLK.
	CLA
	UUOEXT		/BACK TO USER

UFILE4,	GETJTW		/GET HIS JOB STATUS
	 JOBSTS
	CLA
	DATFLD
	TAD JOBSWA
	IOR		/'OR' IN 'RUN' & 'NON-RESIDENT' BITS
	 JSRUN+JSIOT	/ SO HE'S RUNNABLE FOR 'FIP' CALL
	ISZ JOBSWA
	TAD I JOBSWA	/NOW SET HIS DUMMY-WAIT BIT
	AND C7776
	IAC
	DCA I JOBSWA
	WAIT		/ AND WAIT FOR THE WINDOW-TURN

UFPARA=	WS0		/ADDR OF USER PARAMETERS
UFIJSF=	WS1		/FILE STATUS FLAG
C7743,	7743
UFILWA,	UFILWC
UFJF0,	JOBF0
	IFNZRO FILPAR-3	<GLITCH; *.-1>
UFPAR2=	C0003	/FILPAR
	IFNZRO FILPIF-2	<GLITCH; *.-1>
UFIPIF=	C0002	/FILPIF
	IFNZRO FILPWC-3	<GLITCH; *.-1>
UFIPWC=	C0002	/FILPWC-1

UFPARM,	GETUSP
UFLNKA,	UUOLNK
UFERR,	FILERR
UFILIX,	FILIX
UFIRET,	DSURET
UFICTB,	FILCTB
UFIGJF,	GETJFX
UFIQUE,	DSQUE
	PAGE

/RETURN NUMBER OF NEXT RUNABLE JOB IN AC
/CALL	JMS NXTJOB
/	RETURN WITH JOB # IN AC

FILCDA,
NXTJCT,	0
NXTJBN,	0	/LAST JOB NUMBER CHECKED
NXTMAX,	-JOBMAX

FILCT2,
NXTJOB,	0
	TAD BONUS	/IS THERE ANY JOB BROKEN OUT OF I/O WAIT 
	SNA
	JMP NXTJ0
	RUNABL		/IS IT RUNNABLE?
	JMP NXTJ0	/NO,GET THE NEXT JOB
	TAD BONUS	/THIS JOB
	JMP I NXTJOB
NXTJ0,	TAD NXTMAX	/INIT COUNT OF NUMBER OF JOBS
	DCA NXTJCT
NXTJ1,	TAD NXTJBN	/IS IT TIME TO WRAP AROUND TO JOB 1?
	TAD NXTMAX
	SNA CLA
	DCA NXTJBN	/YES
	ISZ NXTJBN	/INCREMENT NUMBER OF JOB UNDER CONSIDERATION
	TAD I FANCOR	/IS THIS JOB IN FIELD 2
	AND C0037
	CIA
	TAD NXTJBN
	SZA CLA
	JMP NXTJ2	/NO
	TAD I FANCOR	/YES, KNOCK DOWN THE NOTRUN AND DISC COMPLETION
	AND CNOTR	/  BITS SINCE WE'RE LOOKING AT IT NOW
	DCA I FANCOR
NXTJ2,	TAD NXTJBN	/IS THE JOB RUNNABLE
	RUNABLE
	JMP NXTJ3	/NO, CONTINUE JOB TABLE ROUND ROBIN
	TAD NXTJBN	/YES, RETURN WITH JOB NO. IN AC
	JMP I NXTJOB

NXTJ3,	ISZ NXTJCT	/HAVE WE TRIED ALL JOBS
	JMP NXTJ1	/NO, KEEP GOING
	JMP I NXTJOB	/YES, RETURN WITH AC=0
/CONSTRUCT TRANSFER BLOCK
/CALL	TAD SEGMENT WINDOW POINTER
/	JMS FILCTB
/	POINTER TO FILPAR

	IFNZRO FILPDA-FILPDX-4	<GLITCH; *.-1>
FILCPD=	C0004	/FILPDA-FILPDX
	IFNZRO FILPWC-FILPDA+2	<GLITCH; *.-1>
FILCWC=	C7776	/FILPWC-FILPDA

FILCSW=	JOBSWA	/POINTER TO SEGMENT WINDOW
FILCPA=	WS2	/POINTER TO FILPAR & FILDA
FILCWA,	0
FILCPX,	0	/POINTER TO FILPDX, FILPDA & FILPWC

FILCTB,	0
	DCA FILCSW	/SAVE POINTER TO SEGMENT IN WINDOW
	TAD I FILCTB
	DCA FILCPA	/ADDRESS OF POINTER TO PARAMETER BLOCK
	ISZ FILCTB	/SKIP ARGUMENT IN CALL
	DATFLD
	TAD I FILCPA	/GET ADDRESS OF PARAMETERS
	IAC		/POINTS TO WORD 2 OF PARAMETERS
	DCA FILCPX
	ISZ FILCPA	/POINTS TO DISC EXTENSION IN CONTROL BLOCK
	CLA CMA
	TAD I FILCSW	/GET SEGMENT #
	CLL RAR
	RTR
	RTR		/MULTIPLY BY 400 SEG SIZE
	DCA FILCT2	/SAVE "PRODUCT"
	TAD FILCT2
	RAL
	AND SEGSM1	/THROW OUT CONTRIBUTION FROM HI ORDER BITS OF EXTENSION
	TAD FIBAS1	/START OF LOGICAL FILE AREA
	CLL RTL
	DCA I FILCPX	/SAVE IN DISC EXTENSION IN PARAMETER BLOCK
	TAD FILCT2	/NOW GET LOW ORDER ADDRESS
	AND SEGLMK
	DCA FILCT2	/AND SAVE IT
	TAD FILCPX	/SET DISC ADDRESS
	TAD FILCPD
	DCA FILCPX	/POINTS TO LOW ORDER ADDRESS IN PAR. BLOCK
	TAD FILCPA
	IAC
	DCA FILCDA	/POINTS TO LOW ORDER ADDRESS IN CONTROL BLOCK
	TAD I FILCDA	/GET WORD ADDRESS SUPPLIED BY USER
	AND SEGSM1	/(WORD IN SEGMENT)
	TAD FILCT2	/+ WORD ADDRESS FROM SEGMENT ARITHMETIC
	DCA I FILCPX	/SAVE IT IN PARAMETER BLOCK
	TAD FILCPX	/SET WORD COUNT
	TAD FILCWC
	DCA FILCPX	/POINTS TO WORD COUNT IN PARAMETER BLOCK
	DCA I FILCPX	/NOTHING TRANSFERRED YET
	TAD FILCDA
	IAC
	DCA FILCWA	/POINTS TO WORD COUNT IN CONTROL BLOCK
FILCT1,	TAD SEGSM1	/SEGSIZ-1
	AND I FILCDA	/LOW ORDER ADDRESS IN CONTROL BLOCK
	DCA FILCT2	/DISC ADDRESS MOD SEGSIZ
	TAD I FILCWA	/GET - WC FROM CONTROL BLOCK
	CLL CIA		/+WC
	TAD FILCT2	/IF WE DO ENTIRE WC WILL WE GO INTO NEXT
	AND SEGLMK	/  SEGMENT?
	SNA CLA
	SZL
	JMP FILCT3
	TAD I FILCWA	/NO
	JMP .+3
FILCT3,	TAD SEGLMK	/SUBTRACT SEGSIZ FROM WC, SO WE STAY IN SAME SEGMENT
	TAD FILCT2
	DCA FILCT2	/WORD COUNT FOR TRANSFER
	TAD FILCT2	/UPDATE WORD COUNT IN PARAMETER BLOCK
	TAD I FILCPX	/OLD VALUE
	DCA I FILCPX	/NEW VALUE
	TAD FILCT2	/UPDATE WORD COUNT IN FILE CONTROL BLOCK
	CIA		/+WC
	TAD I FILCWA	/OLD - WC
	DCA I FILCWA	/NEW - WC
	TAD I FILCWA	/ARE WE DONE?
	SNA CLA
	JMP I FILCTB	/YES
	TAD FILCT2	/INCREMENT DISC ADDRESS
	CLL CIA		/+WC
	TAD I FILCDA	/OLD DISC ADDRESS
	DCA I FILCDA	/NEW DISC ADDRESS
	SZL		/OVERFLOW?
	ISZ I FILCPA	/YES; INDEX DISC EXTENSION
	TAD I FILCSW	/GET CURRENT SEGMENT #
	CLL CML CMA	/-(SEG # +1)
	DCA FILCT2	/SAVE IT
	ISZ FILCSW	/POINTS TO NEXT SEGMENT IN WINDOW
	TAD FILCSW	/ARE WE STILL IN THE WINDOW?
	AND C0007
	SZA CLA		/NEXT POINTER IN CORE?
	JMP FILCT4	/YES, SEE IF NEXT SEGMENT IS CONTIGUOUS
	TAD BASWIN
	TAD FILCSW	/NO - DO A 13-BIT COMPARE WITH BASIC WINDOW
	SNA SZL CLA	/IS IT THE SECOND OR BETTER BASIC SEGMENT?
	JMP I FILCTB	/NO - JUST RETURN
FILCT4,	TAD I FILCSW	/YES - GET THE NEXT SEGMENT
	TAD FILCT2	/CONTIGUOUS SEGMENTS?
	SNA CLA
	JMP FILCT1	/YES; CONTINUE THE TRANSFER
	JMP I FILCTB	/RETURN
FIBAS1,	SWDEX+JOBMAX
	PAGE

/KEYBOARD IOTS

	IFNZRO DSI-1000	<GLITCH; *.-1>
UKEYDB=	WS1	/INPUT BUFFER DDB
UKL2SA,	L2SA
UKEY1A,	UKT1

UKEY,	TAD JOB
	TTYUSE		/GET THIS JOB'S INPUT DDB
	 0
	DCA UKEYDB
	DATFLD
	TAD I UKEYDB	/GET THE CONSOLE STATUS-BITS
	CDF
	AND C1000
	SZA CLA		/IS CONSOLE IN 'SI' MODE?
	REDO		/YES - BACK UP HIS PC AND TRY AGAIN LATER
	JMS I UKEY1A	/WHAT DOES HE WANT TO DO?
	JMP UKEYRS	/READ STRING
UKEYFL,	 JSDEL		/DELIMITER FLAG
	JMP UKWAT1	/KSF AND NO CHARACTERS AROUND...
	RAR		/NOW BIT 0 = 2-BIT AND L = 4-BIT
	SPA CLA		/IS BIT SET FOR 6032?
	DCA L2SA	/YES - JUST CLEAR HIS AC

/EVENT TIME 3
	SNL CLA		/IS BIT SET FOR 6034?
	UUOEXT		/NO - JUST EXIT
	JMS UKEYFE	/GET A CHARACTER FROM BUFFER
	JMP UKWAIT	/NONE AVAILABLE-RESET PC AND WAIT
	DCA .+3		/SAVE CHARACTER
	TAD UKL2SA	/OR INTO USER'S AC
	IOR		/IT WOULD PROBABLY BE ADEQUATE TO JAM IT INTO AC.
UKEYC,	 0
	UUOEXT		/AND BACK TO USER

UKEYFE,	0
	TAD UKEYDB
	CIF DATFLD
	JMS I KSFBUG	/GET A CHARACTER
	ISZ UKEYFE	/YES, FOUND A CHARACTER
	JMP I UKEYFE	/NO CHARACTER FOUND
KSFBUG,	KSFPRA

UKWAIT,	STA		/BACK UP HIS PC
	TAD L2SV0
	DCA L2SV0
	DCA L2SA	/CLEAR HIS AC

UKWAT1,	CLA CLL CML RTR	/AC=2000
	DATFLD
	AND I UKEYDB	/ AND OFF THE STATUS-BITS
	SNA		/WAS AN 'XOFF' SENT?
	JMP UKWAT2	/NO, JUST WAIT FOR KEYBOARD
	CMA		/CLEAR XON BIT IN DDB
	AND I UKEYDB
	DCA I UKEYDB
	TAD UK0177	/MAKE STORE THINK SI IS CALLING
	DCA SOURCE	/(SO WE ALWAYS GET A BUFFER
	TAD UKXON	/OUTPUT AN XON
	DCA TTCHAR	/TO RESTART READER
	TAD JOB
	TTYUSE		/GET OUTPUT DDB ADDRESS
	 1		/ (OUTPUT SIDE)
	STORE		/PUT CHARACTER IN OUTPUT BUFFER
	NOP		/SHOULDN'T HAPPEDN
UKWAT2,	TAD UKEYFL	/CLEAR BIT IN STR1
	UUOEXT

UK0177,	177
UKXON,	221
/READ INPUT STRING

	IFNZRO DDBBRK-2	<GLITCH; *.-1>
UKEYBA=	C0002	/DDBBRK

UKEYRS,	JMS STRINI	/INITIALIZE STRING INPUT
	DATFLD
	TAD I UKEYDB	/GET WORD 1 OF INPUT DDB
	AND C0037
	DCA SOURCE	/CONSOLE #
	TAD UKEYDB	/ADDRESS OF DDB
	TAD UKEYBA	/...+2
	DCA UKBRKM	/POINTS TO BREAK MASK
	TAD I UKBRKM	/GET BREAK MASK
	DCA UKBRKM	/SAVE IT
UKEYR1,	JMS UKEYFE	/GET A CHARACTER
	JMP UKWAT1	/NONE - WAIT FOR ONE
	JMS STRINS	/STORE IT IN USER AREA

	TAD UKBRKM	/IS IT A BREAK CHARACTER?
	CIF DATFLD	/OFF TO FIELD 1 FOR BREAKTEST
	BREAK
	JMP STRINE	/YES - END OF STRING
	JMP UKEYR1	/NO - KEEP GOING
UKBRKM,
STRINI,	0
	STA		/DECREMENT PC FOR REDO
	TAD L2SV0
	DCA L2SV0
	TAD L2SA	/POINTS TO PARAMETERS IN USER AREA
	IAC
	DCA WS0		/ADDR OF USER BUFFER POINTER
	JMP I STRINI	/ALL SET UP

STRINS,	0
	DCA TTCHAR	/SAVE CHAR
	UDF		/SELECT USER FIELD
	ISZ I WS0	/INCREMENT USER BUFFER ADDRESS
	NOP
	TAD I WS0	/GET ADDRESS TO STORE CHARACTER
	DCA JOBSWA
	TAD TTCHAR	/STORE CHAR IN USER BUFFER
	DCA I JOBSWA
	ISZ I L2SA	/DONE?
	JMP I STRINS	/NO
STRINE,	DCA L2SA	/CLEAR AC
	JMP I .+1	/SKIP RETURN
	UUOEX2

PLRACE,	0
	CDF
	STA STL		/SOFT WARE FLAG UP TO SHOW NO FLAG IS EXPECTED
	DCA I RACE2
	TAD NOPNOP
	DCA I RACE3	/NOP FOR THE TIMING COUNTER
	TAD I RACE1
	SZA CLA		/WAS THE BUFFER COMPLETELY FILLED?
	IAC		/NO - THEN DON'T REINITIALIZE IT
	JMP I PLRACE	/RETURN
RACE1,	PTPCNT
RACE2,	PTPBSY
RACE3,	PTPSKA
	PTPISZ
	TIPTP1
RLPTL,	JMS PLRACE	/SET SOFTWARE FLAG
NOPNOP,	CLA CLL		/SAME RETURN IN ANY CASE
	JMP I .+1
	PTPL2

	IFNZRO UUOERR-.&4000	<GLITCH; *.-1>
	*UUOERR
UUOERR,	TAD JOB
	ERROR		/SET "ILLEGAL IOT" ERROR CODE
	 UUOERF
USYN,	WAIT		/AND BACK TO SCHEDULER
	PAGE

/RETURN FILE WINDOW INDEX
/CALL	TAD POINTER TO FILE CONTROL
/	JMS FILIX
/	SEGMENT ADDRESS NOT IN WINDOW
/	NON-EXISTENT FILE ADDRESS
/	OK RETURN WITH ADDRESS OF SEGMENT POINTER

	IFNZRO FILDA-4	<GLITCH; *.-1>
FILIDA=	C0004	/FILDA

FILIX,	0
	DCA FILICN	/SAVE POINTER TO FILE CONTROL
	TAD FILICN
	TAD FILIDA	/4
	DATFLD
	DCA FILSP2	/POINTS TO FILE EXTENSION IN CONTROL BLOCK
	TAD I FILSP2	/FILE EXTENSION
	AND SEGSM1	/# WORDS/SEGMENT -1
	DCA FILSP1	/HIGH ORDER COMPONENT OF SEG #
	ISZ FILSP2	/POINTS TO LOW ORDER ADD
	TAD I FILSP2	/LOW ORDER ADDRESS
	AND SEGLMK	/GET RID OF ADDRESS IN SEGMENT
	CLL RAL
	TAD FILSP1	/HIGH ORDER PART
	RTL		/"DIVIDE" BY 400 SEG SIZE
	RTL
	CMA CML IAC	/ (THIS IS A 13-BIT NEGATE)
	DCA FILISN	/ = - (SEG # - 1)
	TAD I FILICN	/POINT TO WINDOW
	DCA FILICA
	ISZ FILICN	/GET TO SEGMENT # INDEX IN WINDOW
	TAD I FILICA	/GET WORD 1 OF WINDOW
	AND C0007
	SZA		/IS THIS A VALID WINDOW?
	JMP FILIX4	/MAYBE NOT, BUT IT COULD BE THE BASIC WINDOW
	TAD I FILICN	/YES - SEE IF OUR SEGMENT IS IN IT
	TAD FILISN
	SZA SNL		/FILSCT-SN>0?
	JMP FILIX2	/YES. SEGMENT POINTER NOT IN CORE
	TAD C0006
	SNL		/FILSCT+6 - SN < 0?
	JMP FILIX5
	CLA		/YES. SEGMENT POINTER NOT IN CORE
	TAD I FILICA	/ANY MORE SEGMENTS?
	SNA CLA
FILIX1,	ISZ FILIX	/NO. NON-EXISTENT FILE ADDRESS
FILIX2,	CLA
FILIX3,	CDF
	JMP I FILIX	/RETURN
FILIX4,	AND C0006	/IS IT BASIC OR INVALID WINDOW
	SNA CLA		/IS THIS THE BASIC WINDOW? (1ST WORD=7777)
	JMP FILIX3	/NO - INVALID WINDOW
	TAD FILISN	/GET 13-BIT NEGATIVE SEGMENT NUMBER
	TAD BASWIN
	SNA SZL		/ARE WE IN THE BASIC WINDOW?
	JMP FILIX1	/NO - TAKE 'NONEXISTENT ADDRESS' EXIT
	CIA		/AC = SEGMENT POINTER
	JMP FILIX6

FILIX5,	CIA
	TAD C0007	/WINDOW INDEX
	TAD FILICA	/START OF WINDOW
FILIX6,	DCA FILICN	/POINTS TO SEGMENT #
	ISZ FILIX	/SEGMENT ADDRESS IN CORE - EXIT
	TAD I FILICN	/GET SEGMENT # FOR THIS FILE ADDRESS
	SNA CLA
	JMP FILIX3	/ZERO SEGMENT NUMBER IS NOT A SEGMENT!
	TAD FILICN	/EXIT WITH POINTER TO THIS SEGMENT IN AC.
	ISZ FILIX
	JMP FILIX3

FILISN,	0
FILICN,	0
/RETURN USER RUN TIME
/USER CALLS WITH ADDRESS OF THREE WORD BLOCK
/WORD 1 CONTAINS THE JOB #
/THE HI AND LO ORDER RUN TIMES ARE RETURNED IN WORDS 2 AND 3

UURT,	UDF		/USER FIELD
	TAD I L2SA	/JOB #
	SNA		/THIS JOB?
	TAD JOB		/YES
	AND C0037
	TAD JOBTBA
	DCA UCOP0	/SAVE POINTER TO JOB STATUS
	TAD UCOP0
	GETJTI		/HI ORDER RUNTIME
	 JOBRTH
	DCA UCOP1
	TAD UCOP0
	GETJTI		/LOW ORDER 
	 JOBRTM
	DCA UCOP2
	JMP UCOPYS	/COPY IN USER AREA


/RETURN THE TIME OF DAY IN TICS SINCE MIDNITE
/USER CALLS WITH ADDRESS OF TWO WORD BLOCK IN AC
/HI AND LOW ORDER PARTS RETURNED IN WORDS 1 AND 2

UTOD,	TAD CLK1	/-TIME TILL MIDNITE
	CLL
	TAD INKLK1	/TIME AT MIDNITE
	DCA UCOP2	/LOW ORDER TIME NOW
	SZL
	IAC
	TAD CLK2	/-TIME TILL MIDNITE
	TAD INKLK2	/TIME AT MIDNITE
	DCA UCOP1	/TIME NOW (HI ORDER)
	JMP UCOPY2	/COPY IN USER AREA

INKLK1,	INCLK1
INKLK2,	INCLK2

/RETURN THE NUMBER OF FREE DISC SEGMENTS. 'NFSEGS' IS
/SET BY 'FIP' EACH TIME IT EXITS.

USEGS,	TAD NFSEGS	/PASS IT BACK IN HIS AC
	JMP UCOPYA

NFSEGS,	7777	/ (OVERLAYED BY 'FIP')
/RETURN THE USER'S STATUS REGISTERS
/CALLED WITH ADDRESS OF THREE WORD BLOCK IN AC

UCKS,	GETJTW
	 JOBSTS
	DCA UCOP0	/STATUS 0
	DATFLD
	ISZ JOBSWA
	TAD I JOBSWA	/STATUS 1
	DCA UCOP1
	ISZ JOBSWA
	TAD I JOBSWA
	DCA UCOP2	/STATUS 2
	UDF		/SELECT USER FIELD
	TAD UCOP0
	DCA I L2SA
UCOPYS,	ISZ L2SA	/BUMP POINTER
	NOP
UCOPY2,	UDF		/FOR LATER ENTRIES
	TAD UCOP1	/SECOND WORD
	DCA I L2SA
	ISZ L2SA
	NOP
	TAD UCOP2	/THIRD WORD
	DCA I L2SA

UCOPYA,	DCA L2SA	/CLEAR USER AC
	UUOEXT

DEVJO0,
UCOP0,
FILSP1,	0
UCOP1,
FILSP2,	0
UCOP2,	0
/ROUTINE TO EXTRACT JOB NUMBER FROM DDB
/CALL
/	TAD (DDB ADDRESS)
/	JMS DEVJOB
/	RETURN WITH JOB # IN AC

FILICA,
DEVJOB,	0
	IAC
	DCA DEVJO0	/POINTS TO WORD 1 OF DDB
	DATFLD
	TAD I DEVJO0	/GET WORD 1
	AND C0037	/IGNORE JUNK
	CDF
	JMP I DEVJOB	/RETURN
	PAGE

/WE ENTER THIS ROUTINE AT LEVEL 2
/AFTER COMPLETING A DISC TRANSFER
/IF A FILE TRANSFER IS INVOLVED, WE CONTINUE
/WITH IT
/IF OVERLAY, WE GO TO OVERLAY CONTROL

DSURT1=	WS0
DSURT2=	WS1

	IFNZRO FILDA-4	<GLITCH; *.-1>
DSURDA=	C0004	/FILDA
	IFNZRO FILPDA-5	<GLITCH; *.-1>
DSUPDA=	C0004	/FILPDA-1
	IFNZRO FIX-100	<GLITCH; *.-1>
DSFIX=	C0100	/FIX (I/O COMPLETION)
DSUMTB,	-DSUTBL
DGETJX,	GETJFX

DSKCT,	DSKCON
DSKCOD,	0
DSUET1=	WS0

DSURPA,	DSPARM
DSUFEA,	FILERR

DSURET,	IAC		/ERROR IN DISC TRANSFER
	DCA DSKCOD	/SAVE ERROR CODE
	TAD DSKPTR	/POINTS TO REQUEST CURRENTLY RUNNING
	TAD DSUMTB	/FIND RELATIVE INDEX IN TABLE
	CLL RTR		/DIVIDE BY FOUR
	AND C0007	/SAVE FIELD
	TAD CORTBA	/INDEX INTO CORTBL
	DCA DSUCOR
	TAD I DSUCOR	/GET CORTBL ENTRY
	AND C0037	/EXTRACT JOB #
	TAD JOBTBA	/POINTS TO JOBTBL
	DCA DSUJTE	/SAVE JOBTBL ADDRESS
	TAD DSUJTE
	GETJTA		/GET ADDRESS OF STR0
	 JOBSTS
	DCA DSUJST	/SAVE IT
	TAD DSKCOD	/IS THERE AN ERROR
	SZA
	JMP DSURER	/YES JMP OUT OF THE ROUTINE AS QUICKLY AS POSSIBLE
	JMS DSUPAR	/PARAMETER BLOCK ADDRESS
	TAD DSURDA
	DCA DSURT1	/POINTS TO WORD 5 OF PARAMETERS
	TAD I DSURPA	/ADDRESS OF PARAMETERS
	IAC
	DCA DSURT2	/POINTS TO DISC EXTENSION IN PARAMETERS
	DATFLD
	TAD I DSURT1	/DISC EXTENSION FROM CONTROL...
	DCA I DSURT2	/	...TO PARAMETERS
	TAD DSURT2
	TAD DSUPDA
	DCA DSURT2	/POINTS TO DISC ADDRESS IN PARAMETERS
	ISZ DSURT1	/POINTS TO DISC ADDRESS IN FILE CONTROL
	TAD I DSURT1	/DISC ADDRESS FROM CONTROL...
	DCA I DSURT2	/	...TO PARAMETERS
	ISZ DSURT1	/POINTS TO WORD COUNT IN FILE CONTROL
	CLL CMA RAL
	TAD DSURT2
	DCA DSURT2	/POINTS TO WORD COUNT IN PARAMETERS
	TAD I DSURT2	/SAVE TEMPORARILY -WC FROM PARAMETERS
	CIA
	DCA DSKCOD
	TAD I DSURT1	/MOVE WC FROM FILE CONTROL...
	DCA I DSURT2	/	...TO PARAMETERS
	ISZ DSURT2	/POINTS TO CORE ADD IN PARAM.
	TAD DSKCOD	/UPDATE CORE ADD BY COUNT TRANSFERRED
	TAD I DSURT2
	DCA I DSURT2	/SAVE NEW ADD
	TAD I DSURT1	/GET WORD COUNT FROM CONTROL
	CDF
	SNA CLA		/ARE WE DONE?
	JMP DSURER	/YES

/MOVE SEGMENT WINDOW
	TAD DSUJTE	/SET JOBLNK
	GETJTA
	 JOBLNK
	DCA DSKCOD	/SAVE POINTER TO JOBLNK
	TAD I DSURPA	/GET ADDRESS OF PARAMETER BLOCK
	DATFLD
	DCA I DSKCOD	/AND SAVE IN JOBLNK
	CDF
	DCA I DSURPA	/CLEAR DSPARM
	TAD I DSUCOR	/GET CORTBL ENTRY FOR TRANSFERRING FIELD
	DCA I RDFJBA	/ & SET IT FOR 'READFI'
	TAD .+3
	DCA EXITA	/FUDGE EXIT SO WE GO THRU READFI
	JMP DSURE1	/AND AWAY.
	DSUEXT
DSURER,	DCA DSKCOD	/SAVE ERROR STATUS
	TAD I DSURPA	/GET ADDRESS OF PARAMETER BLOCK
	DCA .+3		/FOR CALL TO FILERR
	TAD DSKCOD	/ERROR CODE
	JMS I DSUFEA	/HANDLE ERROR
	0
	TAD CLK1	/SET DISC COMPLETION BIT 7/8-TH OF
	AND C0007	/  THE TIME
	SZA CLA
	TAD DSFIX	/YES
	TAD I DSUCOR	/NO
	DCA I DSUCOR
DSURE1,	ISZ DSUJST	/SET INACTIVE FLAG IN STR1
	TAD DSKPTR	/FIGURE OUT WHICH INTERNAL FILE #
	TAD DSUMTB
	JMS I DGETJX
	DATFLD
	TAD I DSUJST	/NOW SET FILE READY & DUMMY WAIT BIT
	AND C7776
	IAC
	DCA I DSUJST	/SAVE STR1
DSURE4,	TAD DSKPTR
	DCA DSUET1	/SET QUEUE POINTER
	DATFLD
	DCA I DSUET1	/CLEAR THE 'DSUTBL' ENTRY
	CDF
	TAD I DSURPA	/GET THE PARAMETER BLOCK ADDRESS
	SZA
	RETBLK		/ AND RETURN IT
	CLA
	JMS I DSKCT	/THEN DECREMENT 'DSBUSY'
	EXIT		/ AND EXIT

RDFJBA,	RDFJOB
DSUCOR,	0	/POINTER TO CORE TABLE ENTRY
DSUJST,	0	/POINTER TO JOB STATUS
DSUJTE,	0	/JOB TABLE ENTRY

DSUPAR,	0	/GET PARAMETER BLOCK ADDRESS
	TAD I DSURPA	/GET ADDRESS
	TAD C0007	/GET POINTER TO LAST WORD IN BLOCK
	DCA DSUET1
	DATFLD
	TAD I DSUET1	/GET ADDRESS OF FILE CONTROL
	CDF
	JMP I DSUPAR	/EXIT

OVERL1,	JMS DSUPAR	/GET ADDRESS OF FILE CONTROL
	SZA
	JMP OVE2
	TAD I FANCOR
	TAD C0100	/DISC I/O FINISHED BIT
	DCA I FANCOR
	TAD RSCHEA
OVE2,	DCA I L2Q
	JMP DSURE4

/ROUTINE TO HANDLE THE 'CON' IOT - WE RETURN THE
/KEYBOARD NUMBER OF THE SPECIFIED JOB.
UCON,	TAD L2SA	/GET THE JOB NUMBER
	SNA		/ANYTHING PASSED?
	TAD JOB		/NO - GET HIS OWN JOB #
	AND C0037
	TAD TTYTBB
	DCA WS0		/SET THE 'TTYTBL' ENTRY POINTER
	DATFLD
	TAD I WS0	/GET THE UNIT #
	DCA L2SA	/ AND RETURN IT IN HIS AC
	UUOEXT

TTYTBB,	TTYTBL
/ROUTINE TO RECOGNIZE AND REPLY TO ^C
/CALLED ONLY FROM 'GIR':
/	JMS GIRCT0
/	UNABLE TO ECHO "^C" FOR SI
/	'SI' ECHOING HANDLED PARTIALLY - "C" IN TTCHAR
/	PROGRAM RESTART HANDLED

GIRCT0,	0
	TAD I GIRINA	/ADD OF INPUT DDB
	DATFLD
	JMS I GIRFB	/IS IT IN 'SI' MODE?
	JMP GIRCT1	/YES - JUST ECHO "^C"
	CDF
	TAD I GIRINA
	JMS I GIRJBA	/NO - GET USER'S JOB #
	CIF 10
	JMS I GIRTAP	/ AND STOP ANY DECTAPES
	TAD JOBTBA	/WE GET HIS JOB # BACK AGAIN
	GETJTI		/PICK UP HIS STR0
	 JOBSTS
	RAL		/CLEAR RUN BIT
	CLL CML RAR	/ & FORCE IT BACK ON
	DATFLD
	DCA I JOBSWA
	ISZ JOBSWA	/POINTS TO STR1
	TAD I JOBSWA
	AND GIRFC1	/CLEAR HIS COMPLETION BITS & JSWAIT
	DCA I JOBSWA
	CLA CLL CML RTL	/AC = 2
	TAD JOBSWA
	DCA WS1		/POINTS TO WAIT-MASK 1
	TAD I WS1
	AND GIRFC2	/CLEAR ALL NON-CRITICAL WAIT-BITS
	SNA		/IS HE STILL WAITING FOR SOMETHING?
	ISZ I JOBSWA	/NO - INDICATE NO WAIT IN STR1
	IAC
	DCA I WS1
	ISZ GIRCT0	/INDICATE THIS WAS A PROGRAMMATIC RESTART
	JMP GIRCT2

/THE USER TYPED ^C WHILE HE WAS IN 'SI' MODE - JUST ECHO
/"^C" & LET 'SI' FIND THE DDB STATUS-BIT.
GIRCT1,	TAD GIRUPB
	DCA TTCHAR
	CDF
	TAD I GIROTA
	STORE		/OUTPUT THE "^"
	JMP I GIRCT0	/NO ROOM - TAKE ERROR EXIT
	TAD GIRC
	DCA TTCHAR	/NOW PASS A "C" BACK TO MAIN 'GIR' TO OUTPUT
GIRCT2,	ISZ GIRCT0	/INCREMENT RETURN TO INDICATE ALL WENT WELL
	JMP I GIRCT0	/ & RETURN

GIRC,	"C
GIRFB,	CONCB
GIRFC1,	-JSDEL-JSTEL-JSWAIT-1
GIRFC2,	-JSTIME-JSDEL-JSTEL-JSPTR-JSPTP-JSWAIT-1
GIRINA,	GIRDBA
GIRJBA,	DEVJOB
GIROTA,	GIRDTA
GIRTAP,	CNTRLC	/DECTAPE-STOP ROUTINE IN FIELD 1
GIRUPB,	"^
/ROUTINE TO SET UP SWAP
/CORTBL POINTER TO FIELD TO BE SWAPPED OUT IN WS0
/FINISH= +FIELD # FOR SWAP IN ;FINISH= -FIELD# FOR SWAP OUT
/FIT=JOBTO BE SWAPPED IN OR PHANTOM TO BE BROUGHT IN
/FORCE=FIELD TO BE SWAPPED OUT
/ENTER AT SWAP FOR SWAP IN
/ENTER AT SWPOUT FOR SWAP OUT


SWPOUT,	TAD WS0		/OR SWAP BIT INTO CORTBL
	IOR
	 FSWP
	TAD I WS0	/JOBS ARE THE ONLY ONCE TO BE SWAPPED OUT
	JMS TRAC	/GET THE TRAC # FOR THIS JOB
	DCA OUTTRC	/SAVE IT
SWAP,	TAD FINISH	/FINISH HAS FIELD # FOR SWAP ACTIVITY + OR -
	SPA
	CIA		/GET THE ABSOLUTE VALUE
	CLL RTL
	RAL		/IN POSITION 00X0
	DCA SQREQ	/SAVE IT FOR SETTING UP DISC  IO
	TAD FIT
	AND C0600
	SNA		/IS IT A PHANTOM WE NEED?
	JMP SWAP1	/NO - JOB IS TO BROUGHT IN
	AND C0400	/IS FIP NEEDED?
	SZA CLA
	IFZERO RF08-40 <TAD C0100>	/YES, DF32 NEEDS TRAC IN POSITION 0X00
	IFZERO RF08 <IAC >	/YES, RF08 NEEDS TRAC IN POSITION 000X
SWAP3,	DCA INTRC
	ISZ DSBUSY	/IS ANY DISC ACTIVITY GOING ON?
	SCHED		/YES, SO FIND A RESIDENT JOB
	JMS I SWPIOA	/NO, START THE SWAP IO
	SCHED		/FIND A RESIDENT JOB IN THE MEANWHILE
SWAP1,	TAD FIT		/GET THE JOB # TO BE SWAPPED IN
	JMS TRAC	/GET ITS TRAC #
	JMP SWAP3

/SUBROUTINE TO BUILD THE DISC CONTROL-WORD TO TRANSFER
/THE SWAP AREA FOR THE JOB WHOSE NUMBER IS IN THE AC.
TRAC,	0
	AND C0037	/JUST GET THE JOB #
	SNA		/IS IT REASONABLE?
	REBOOT		/NO - ERROR *****
	TAD SWBASE	/YES - GET TRAC # WHERE SWAP AREA BEGINS - 1

	IFZERO RF08-40 <
	CLL RTL; RTL; RTL	/TRAC # IN POSITION 0X00 FOR DF32
	>
	JMP I TRAC	/RETURN

SWBASE,	SWDEX-1		/SWAP TRACK OF JOB 1
/IF WE CAN'T FINISH AN IOT FOR LACK OF SYSTEM FACILITIES,
/WE BACK UP THE USER'S PC TO POINT TO THE SAME IOT AND
/HOPE THAT THINGS WILL LOOSEN UP SHORTLY.

REDO0,	CLA CLL CMA
	TAD L2SV0	/BACK UP HIS PC
	DCA L2SV0
	WAIT		/ AND RESCHEDULE

/ROUTINE TO TURN USER ON IF READER IS OUT OF TAPE
/ENTERED ON L2QUE BY SCHED IF READER TIMER COUNTS
/DOWN BEFORE A BUFFERFUL OF CHARACTERS IS READ
PTRHNG,	JMP PTPHNG	/PUNCH IS HUNG
	DATFLD
	TAD I PTRDV2	/GET ADDRESS OF DDB WORD 0
	SNA		/IS IT STILL THERE?
	JMP .+3		/NO - SKIP THE FLAG
	IOR		/YES - OR IN END-OF-TAPE
	 PTRTAP
	CDF
	JMP I .+1	/NOW RUN REST OF LEVEL 2 SERVICE
	PTRL2

PTRDV2,	DEVTBE		/POINTER TO READER DEVTBL ENTRY
PTRTAP=	1000		/BIT 2 OF WORD 0

PTPHNG,	DATFLD		/PUNCH FLAG HASN'T COME UP
	TAD I PTPDV2
	JMS I PTJOB	/GET JOB # FROM DDB
	ERROR
	 HUNGDV
	JMP I .+1
	RLPTL		/RUN THE REST OF LEVEL 2 SERVICE

PTPDV2,	DEVTBE+1
PTJOB,	DEVJOB
	IFNZRO INTCOM-.&4000	<GLITCH; *.-1>
	*INTCOM
INTCOM,	LSF		/CHECK FOR UNREQUESTED FLAGS
	JMP .+3		/ AND CLEAR THEM
	LCF
	DISMIS
	PSF
	DISMIS		/UNDEFINED INTERRUPT - IGNORE IT (MIGHT BE KL8E BUG) *****
	PCF
	DISMIS
	PAGE
/GENERAL INPUT ROUTINE
/CALL	UNIT # IN SOURCE, CHAR IN TTCHAR
/	GIR
/	 DEVTBL ADDRESS
/	BUFFER OVERFLOW RETURN. CHAR NOT DISTRIBUTED
/	NORMAL RETURN

SIBRK,	SIBRKM		/THIS MUST BE FIRST WORD ON PAGE; TAD SIBRK=1200
/SWBDA,	SWKBD		/WE USE TAD SIBRK TO SAVE SPACE
MCC,	-203	/- ^C
GIRUPA,	"^
GIRB,	"B
GIRCLB,	CLRBUF
GIRCLF,	-JSTEL-JSDEL-1
GIRCTL,	GIRCT0
GIRDTA,	0
GIRFA,	CONCB
GIRJOB,	DEVJOB
	IFNZRO GIR00-1-GIRDBA	<GLITCH; *.-1>
GIRDBA,	0	/MUST PRECEDE 'GIR00' (SET BY 'SI')

GIR00,	0
	TAD I GIR00
	DCA GIRDBA	/DEVTBL POINTER TO INPUT DDB
	ISZ GIR00
	RDF		/SET UP RETURN TO CALLER
	TAD C6203
	DCA GIRFUL
	TAD GIRDBA	/INPUT OR OUTPUT DDB?
	CLL RAR
	SNL CLA
	IAC		/INPUT
	TAD GIRDBA	/OUTPUT
	DCA GIRDTA	/ = POINTER TO OUTPUT DDB
	DATFLD
	TAD I GIRDBA
	DCA GIRDBA	/ = ADDRESS OF INPUT DDB
	TAD SOURCE
	AND C0100
	SZA CLA		/IS THIS THE USER TYPING?
	JMP GIR9	/NO - IT'S A PROGRAM OR SI - IGNORE CTRL CHARS
	TAD TTCHAR
	TAD MCC
	SNA		/YES - IS IT A CTRL/C?
	JMP GIR1	/YES - SET FLAG & CLEAR BUFFERS
	IAC
	SZA CLA		/NO - IS IT A CTRL/B?
	JMP GIR9	/NO - JUST HANDLE NORMALLY
	TAD GIRDBA	/DDB ADDRESS
	JMS I GIRFA	/IN SI ALREADY?
	JMP GIR2	/YES - CLEAR OUTPUT BUFFER
	TAD GIRDBA
	IOR		/NO - SET KEYBOARD IN 'SI' MODE
	 DSI
	JMP GIR3	/THEN GO CLEAR THE INPUT BUFFER
GIR1,	TAD GIRDBA
	IOR		/INDICATE 'CTRL/C' IN DDB
	 CTRLC
GIR2,	TAD I GIRDTA
	SZA		/IS THERE AN OUTPUT DDB?
	JMS I GIRCLB	/YES - CLEAR IT
GIR3,	DATFLD
	TAD I GIRDBA
	AND GIRSIC
	SZA CLA		/IS 'SICOM' SET?
	JMP GIR4	/YES - WE CAN'T MESS UP SI BY CLEARING INPUT
	TAD GIRDBA
	JMS I GIRCLB	/NO - CLEAR INPUT BUFFER
GIR4,	TAD GIRDBA
	JMS I GIRJOB	/GET JOB # TYPING 
	SNA		/IS HE LOGGED IN?
	JMP GIR5	/NO
	TAD JOBTBA
	GETJTI		/YES - GET HIS STR1
	 JOBSTS+1
	AND GIRCLF	/ & CLEAR JSDEL AND JSTEL
	DATFLD
	DCA I JOBSWA
GIR5,	DATFLD
	TAD I GIRDTA
	CDF
	SZA		/DOES HE ALREADY HAVE AN OUTPUT DDB?
	JMP GIR6	/YES
	TAD GIRDTA
	GETDDB		/NO - GET ONE FOR ECHOING
	JMP GIRFUL	/NONE AVAILABLE - TAKE ERROR EXIT
	JMP GIR5	/ (SAVE TWO INSTR. THIS WAY)
GIR6,	DCA GIRDTA	/ = ADDRESS OF OUTPUT DDB
	TAD TTCHAR
	TAD MCC
	SNA		/IS OUR CHARACTER A CTRL/C?
	JMP GIRCTC	/YES - GO HANDLE IT
	IAC
	SNA CLA		/NO - IS IT A CTRL/B?
	JMP GIRCTB	/YES - JUST TYPE "^B"
	TAD GIRDBA
	STORE		/NO - JUST PUSH IT INTO THE INPUT BUFFER
	JMP GIRFUL	/WON'T FIT

SIPTR=	TAD SIBRK
	IFNZRO SWKBD-SIPTR	<GLITCH; *.-1>
SWBDA,	TAD SIBRK	/ (ASSUMED TO BE ADDRESS OF 'SWKBD')
	CIF DATFLD
	BREAK		/IS THIS A BREAK-CHARACTER FOR 'SI'?
	SKP		/YES
	JMP GIR8	/NO
	TAD GIRDBA
	DATFLD
	IOR		/SET 'SICOM' TO INDICATE WE HAVE A COMMAND
GIRSIC,	 SICOM
GIR7,	ISZ COMCNT	/ & INCREMENT OUR COMMAND COUNTER
GIR8,	TAD GIRDBA
	JMS I GIRJOB	/GET HIS JOB # AGAIN
	SNA CLA		/IS HE LOGGED IN?
	JMP GIREXT	/NO - THEN WE DON'T ECHO
	TAD GIRDTA
	STORE		/YES - ECHO-TYPE THE CHARACTER
	JMP GIRFUL
GIREXT,	ISZ GIR00	/INCREMENT RETURN
GIRFUL,	0		/BACK TO CALLING FIELD
	JMP I GIR00

/THE CHARACTER IS EITHER FROM A PROGRAM OR 'SI' OR
/IS NEITHER A CTRL/B OR A CTRL/C; I.E. WE JUST PUSH
/IT THROUGH NORMALLY.
GIR9,	TAD GIRDBA
	JMS I GIRFA	/IS THIS GOING TO SI?
	JMP GIR5	/YES
	JMS I SWBDA	/NO - PUSH IT THROUGH & CHECK 'DUPLEX'
	JMP GIRFUL	/NO ROOM - TAKE ERROR EXIT
	JMP GIREXT

/THE CHARACTER IS A CTRL/B - JUST ECHO "^B".
GIRCTB,	TAD GIRUPA
	DCA TTCHAR
	TAD GIRDTA
	STORE		/OUTPUT THE "^"
	JMP GIRFUL
	TAD GIRB
	DCA TTCHAR	/THEN SET TTCHAR = "B"
	JMP GIR8	/ & GO FINISH UP

/THE CHARACTER IS A CTRL/C - GO ECHO "^C" IF WE'RE IN 'SI' MODE
/OR CLEAR ANY REASONABLE WAIT-BITS TO RESTART HIS PROGRAM
GIRCTC,	JMS I GIRCTL	/GO HANDLE THE CTRL/C
	JMP GIRFUL	/NO ROOM - ERROR
	JMP GIR7	/'SI' COMMAND
	JMP GIREXT	/PROGRAM COMMAND
	PAGE

/OUTPUT A CHARACTER
/CALL	LINE # IN SOURCE
/	JMS CHOUT
/	CHARACTER
/	RETURN

CHOUT,	0
IFZERO D680-2 <
	STA
	TAD SOURCE
	SMA CLA		/CTY?
	JMP CHOUT1	/NO
	TAD I CHOUT	/YES - OUTPUT CHARACTER
	JMP I TEST1
CHOUT1,	TAD I CHOUT	/GET CHARACTER
	DCA TTCHAR
	STA
	TAD SOURCE	/DC08 LINE = TSS/8 CONSOLE -1
	T8SOF		/PASS CHARACTER TO DC08
	NOP
CHOUT2,	ISZ CHOUT		/RETURN
	JMP I CHOUT
TEST1,	TEST
	>

IFZERO D680 <
	IFNZRO CPU-3  <
	TAD SOURCE	/LINE NUMBER
	TAD TDEV	/DEVICE CODE LIST
	IAC
	DCA CONOU3	/POINTER TO DEVICE CODE FOR THIS LINE
	TAD I CONOU3	/PICK UP DEVICE CODE
	TAD C6006	/TLS-DEVICE CODE
	DCA CHOUT1	/TAD SOURCE
	TAD SOURCE
	TAD TBUFF
	DCA CONOU3	/PTR TO TTY BUFFER FOR THIS LINE

	TAD I CHOUT
CHOUT1,	0		/OUTPUT THE CHARACTER
	DCA I CONOU3	/PUT IT IN THE BUFFER
	ISZ CHOUT
	JMP I CHOUT
>
			IFZERO	CPU-3	<

	TAD	SOURCE		/GET THE LINE NUMBER IN THE AC
	TAD	TBUFF		/GET THE BUFFER POINTER NOW.
	DCA	CONOU3		/AND STORE AWAY IN A TEMP.
	TAD	SOURCE		/GET THE LINE NUMBER AGAIN
	DCA	CHOUTP		/SAVE AWAY FOR A SECOND
	TAD I	CHOUT		/GET THE CHARACTER
	ISZ	CHOUT		/BOP PAST THE CHARACTER
	JMS	JBDC02		/OUTPUT THE CHARACTER NOW.
CHOUTP,	0			/LINE NUMBER GOES HERE
	DCA I	CONOU3		/SAVE BACK
	JMS I	JBENDC		/REENABLE THE DC02 CONTROLLER.
	JMP I	CHOUT		/AND RETURN NOW.


JBDC02,	0
	DCA	DC02CH		/SAVE THE CHAR FOR ASECOND
	TAD I	JBDC02		/GET THE LINE NUMBER
	ISZ	JBDC02		/BOP PAST IT,BROTHER
	SZA			/IS IT THE CTY [0?]
	JMP I	JBBLST		/GO DOWN AND OUTPUT TO THE DC02.
	TAD	DC02CH		/GET THE CHARACTER NOW.
	TLS			/BYE BYE
JBBTSL,	JMP I	JBDC02		/RETURN NOW.

JBBLST,	JBDCY			/POINTER TO THE DC02 OUTPUTER.
JBENDC,	DC02EN			/POINTER TO THE DC02 ENABLER.

		>	>
/FILL ALL OUTPUT BUFFERS

CONT1,	0
CONDDB,	0
	IFNZRO DDBOUP-6	<GLITCH; *.-1>
CONOUP=	C0006	/DDBOUP
	IFNZRO DDBINP-DDBOUP+2	<GLITCH; *.-1>
CONINP=	C7776	/DDBINP-DDBOUP

CONOUT,	0

	IFZERO D680-2 <
	IOF
	TAD TCHAR
	SMA SZA CLA
	JMP CONOU6
	TAD TCHAR
	SZA CLA
	JMP CONM60+3
	JMS CONFET
	JMP CONOU6
CONM60,	TLS
	STL RAR
	DCA TCHAR		/REMEMBER IT IS BEEN OUTPUT
	JMS CONFET
	JMP CONOU6
	TAD C1000
	DCA TCHAR
CONOU6,	ION
	TAD T8NL
	DCA CONLPC	/LOOP COUNT:=#LINES
CONOU1,	TAD CONLPC
	TAD T8NUML
	TAD T8K36
	DCA CONFET	/POINTS TO THIS LINE'S SECOND OUTBUF
	TAD I CONFET
	SZA CLA		/ANY ROOM IN THE INN??
	JMP CONOU3	/NO, SO GO AWAY
	TAD CONLPC
	TAD T8NUML
	IAC
	JMS CONFET
	JMP CONOU3
	DCA TTCHAR
	TAD CONLPC
	TAD T8NUML
	T8SOF
	NOP
CONOU3,	ISZ CONLPC	/DONE?
	JMP CONOU1	/NO
	JMP I CONOUT	/YES
CONLPC,	0
	>

	IFZERO D680 <
	TAD TBUFF
	DCA CONOU1	/BUFFER POINTER

	IFNZRO CPU-3 <
	TAD TDEV
	IAC
	DCA CONOU2	/DEVICE CODE POINTER
	>
	DCA CONOU3	/DEVICE COUNTER
CONO11,	TAD I CONOU1	/PICK UP A CHARACTER
	SPA SNA CLA	/IS IT WAITING TO GO OUT?
	JMP CONO14	/NO - WE'RE READY FOR ANOTHER
CONOU6,	ISZ CONOU1

	IFNZRO CPU-3 <
	ISZ CONOU2	/ADVANCE THE DEVICE-CODE POINTER
	>
	ISZ CONOU3	/INCREMENT THE KEYBOARD NUMBER
	TAD TBUFFE	/END OF BUFFER
	CMA
	TAD CONOU1
	SZA CLA		/ARE WE DONE?
	JMP CONO11	/NO - CHECK THE NEXT LINE

	IFZERO CPU-3 <
	JMS I JBENDC	/REENABLE THE DC02 CHANNELS.
	>
	JMP I CONOUT	/ AND RETURN
/
/HERE WE FETCH A CHARACTER FROM THE USER'S BUFFER AND
/EITHER SHIP IT OFF OR PUT IT INTO 'TBUFF' FOR THE
/INTERRUPT HANDLER TO USE.
CONO14,	TAD CONOU3
	JMS CONFET	/FETCH A CHARACTER FROM THE USER BUFFER
	JMP CONOU6	/NONE AVAILABLE
	DCA TCHAR	/SAVE THE CHARACTER

	IFNZRO CPU-3 <
	TAD I CONOU2	/PICK UP DEVICE CODE
	TAD C6006	/TLS-DEVICE CODE
	DCA CONO15
	>
	TAD I CONOU1
	SZA CLA		/IS THE PRINTER ALREADY ACTIVE?
	JMP CONO16	/YES - PUT NEW CHARACTER IN FINAL BUFFER
	TAD TCHAR	/NO - SEND OUT THIS CHARACTER

	IFNZRO CPU-3 <
CONO15,	0		/OUTPUT THE CHARACTER
	>

	IFZERO CPU-3 <
	JMS JBDC02	/OUTPUT THE CHARACTER NOW
CONOU3,	0		/THE LINE NUMBER
	>
	STL RAR
	JMP CONJBP	/NOW MARK AS DONE

CONO16,	TAD C1000	/FORCE CHAR TO BE NON-ZERO
	TAD TCHAR
CONJBP,	DCA I CONOU1	/PLACE NEW CHARACTER IN FINAL BUFFER
	JMP CONO11	/SEE IF WE CAN DOUBLE-FEED THIS LINE

CONOU1,	0
	IFNZRO CPU-3 <
CONOU2,	0
CONOU3,	0
	>
	>
CONFET,	0
	CLL RAL
	IAC
	TAD DEVTBA
	DCA CONDDB	/NOW POINTS TO USER'S OUTPUT ENTRY IN DEVTBL
CONOU5,	DATFLD
	TAD I CONDDB
	CDF
	SNA		/DOES  THIS USER HAVE AN OUTPUT DDB?
	JMP I CONFET	/NO; THUS HE HASN'T ANY CHARACTERS TO OUTPUT.
	CIF+10		/FETCH IN FIELD 1
	FETCH
CONO12,	 -12
	JMP CONOU4	/BLOCK EMPTY. RETURN IT TO FREE STORAGE
	JMP CONOU4	/NONE LEFT
	ISZ CONFET	/GOT A CHAR
	JMP I CONFET
CONOU4,	DATFLD
	TAD I CONDDB
	TAD CONOUP
	DCA CONT1	/NOW POINTS TO OUTPUT BLOCK POINTER
	TAD I CONT1	/PICK UP OUTPUT BLOCK POINTER
	CDF
	SNA		/IS THERE STILL SOME OUTPUT BUFFER?
	JMP I CONFET	/NO, SO WE'RE DONE!
	RETBLK		/YES, SO RETURN THE ONE WE JUST EMPTIED
	DATFLD
	DCA I CONT1	/SET THE POINTER TO THE NEXT OUTPUT BUFFER (OR 0)
	STA
	TAD CONDDB	/POINTS TO  INPUT DDB PTR IN DEVTBL
	DCA CHOUT
	TAD I CHOUT
	JMS I CONCBA	/IS INPUT SIDE IN SI MODE?
	JMP CONO20	/YES-DON'T PLAY WITH JSTEL
	TAD I CONDDB	/NO-GET HIS JOB #
	JMS I CONJOB	/EXTRACT JOB# FROM DDB
	DATFLD
	SZA		/DOES THIS DDB BELONG TO A DEFINED JOB?
	JMP I CONO7A	/YES
	TAD I CONT1
	SZA CLA		/NO - IS THERE ANOTHER BUFFER?
	JMP CONOU8
	TAD I CONDDB	/NO - RELEASE THE DDB
	CDF
	RETBLK
	CLA
CONO10,	DATFLD
	DCA I CONDDB
	CDF
	JMP I CONFET

CONO70,	GETJTA		/TURN ON JSTEL
	 JOBSTS+1
	DATFLD
	IOR
	 JSTEL
CONO20,	TAD I CONT1
	SNA CLA		/ARE THERE ANY MORE OUTPUT BUFFERS?
	JMP CONOU9	/NO - THEN RESET THE FILL POINTER
CONOU8,	ISZ CONT1
	TAD CONO12
	DCA I CONT1	/YES - JUST RESET THE EMPTY COUNTER
	JMP CONOU5

CONOU9,	TAD CONINP
	TAD CONT1
	DCA CONDDB
	JMP CONO10

CONO7A,	CONOU7
CONJOB,	DEVJOB
CONCBA,	CONCB
	PAGE
	IFZERO D680 <

T8CNT4,	TIBUFF

T8INS,	0
	TAD KBUFFE	/END OF KEYBOARD BUFFER
	CMA
	TAD T8CNT4
	SNA CLA
	JMP T8INS1	/END OF BUFFER
	TAD I T8CNT4
	SNA
	JMP T8INS2	/EMPTY SLOT
	IFZERO TTYEVEN-1 <
	AND CC0177
	TAD C0200
	>
	IFZERO TTYEVEN	<
	AND C0377
	NOP
	>
	DCA TTCHAR
	DCA I T8CNT4	/CLEAR DEVICE BUFFER
	TAD KBUFF
	CIA
	TAD T8CNT4
	ISZ T8INS
	JMP I T8INS

T8INS1,	TAD KBUFF
	DCA T8CNT4
	JMP I T8INS
CC0177,	177

T8INS2,	ISZ T8CNT4
	JMP T8INS+1
	IFNZRO CPU-3  <
TSER,	DCA .+4		/SET THE 'TLS' IOT
	TAD I KTBUF	/CHECK OUR SINGLE-CHAR BUFFER
	SPA SNA		/ANOTHER CHAR READY TO GO?
	JMP TSER1	/NO - JUST CLEAR THE FLAG
	 HLT		/OUTPUT A CHARACTER
	CLA CLL CMA	/SET TBUFF NEGATIVE
	DCA I KTBUF
	DISMIS
TSER1,	CLA IAC
	TAD INT4	/CONSTRUCT TCF
	DCA .+1
	 HLT
	JMP TSER2	/FORCE FEED ROUTINE ACTIVE

KSER,	DCA .+1		/SET OUR 'KRB'
	 HLT
	TAD C1000	/FORCE THE CHAR .GT. 0
TSER2,	DCA I KTBUF
	ISZ ECHOFL	/IS ECHO SCHEDULED?
	DISMIS		/YES
	TAD .+2		/NO - SCHEDULE IT NOW
	DISMIS
	ECHO		/LEVEL 2 ECHO SERVICE

ECHOFL,	-1		/-1 IF INPUT CHARACTERS NOT PROCESSED

/
/ROUTINE TO CHECK A LIST OF DEVICE CODES FOR A 
/SKIPPING DEVICE. CALL:
/	TAD (DEVLST-1)
/	JMS I (INT2)
/	 END OF DEVLST + 1
/	RETURN IF INTERRUPTING DEVICE WAS FOUND
/	RETURN IF NO FLAG FOUND
/
INT2,	0
	DCA T8AX1
INT1,	TAD I T8AX1
	TAD C6001	/KSF-DEVICE CODE
	DCA .+1
INT4,	 HLT
	JMP INT5	/NOT THIS DEVICE
	TAD T8AX1	/WE FOUND THE DEVICE
	TAD BUFCNV
	DCA KTBUF	/SET THE SINGLE-CHAR BUFFER POINTER
	TAD INT4
	TAD C0005	/ AND BUILD THE 'TLS' OR 'KRB'
	JMP INT3
INT5,	TAD T8AX1
	CMA
	TAD I INT2
	SZA CLA		/HAVE WE REACHED THE END OF THE LIST?
	JMP INT1	/NO - KEEP POLLING THE TTY LINES
	ISZ INT2	/YES - INTERRUPTING DEVICE WASN'T FOUND

	IFZERO TC01-1 <
	JMS I DTCHK1	/CHECK THE DECTAPES AGAIN
	>
INT3,	ISZ INT2
	JMP I INT2

	IFNZRO TIBUFF-TIDEV-TOBUFF+TODEV	<GLITCH; *.-1>
BUFCNV,	TIBUFF-TIDEV
C0005,	5
KTBUF,	0
C6001,	6001
	IFZERO TC01-1 <
DTCHK1,	DTCHK
	>>
	IFZERO CPU-3  <
DC02K,	0
	DCA I	DD02LN		/ZAP OUT THE DC02 LINE.
	KSF			/WAS IT THE CTY?
	SKP			/NOPE
	JMP I	DC02K		/AND RETURN
	JMS	DC02CK		/CHECK FOR INPUT NOW
	MKTF			/INPUT FLAGS
	ISZ	DC02K		/SKIPS IF INPUT ON RETURN, THUS AVOIDING
	JMP I	DC02K		/THE ISZ


DC02T,	0
	DCA I	DD02LN		/ZAP OUT THE LINES NOW.
	TSF			/IS IT THE CTY?
	SKP
	JMP I	DC02T		/RETURN NOW
	JMS	DC02CK		/CHECK FOR THE DC02 NOW
	MTPF			/OUTPUT FLAGS
	ISZ	DC02T		/BOP UP THE RETURN IF NOT FOUND
	JMP I	DC02T		/RETURN NOW.


DC02CK,	0			/CHECKS FOR A GIVEN DC02 INTERUPT
	TAD I	DC02CK		/THE THING WE WANT
	DCA	DC02S		/SAVE AWAY FOR THE SUBORUTINE TO USE
	ISZ	DC02CK		/BOP PAST THE SUBROUTINE ARGUEMENT
	TAD	DC02ALL		/CHECK ALL GROUPS NOW.
	JMS	DC02SUB		/READ IN THE STUFF
	SNA CLA			/ANY GROUP?
	JMP I	DC02CK		/NOPE. RETURN NOW.
	TAD	DC02L1		/CHECK GROUP ONE NOW
	JMS	DC02GK		/CHECK IT,BABY
	TAD	DC02L2		/CHECK GROUP TWO NOW.
	JMS	DC02GK		/AND SO ON DOWN FOR ALL FOUR GROUPS
	TAD	DC02L3
	JMS	DC02GK
	TAD	DC02L4		/LAST ONE
	JMS	DC02GK		/GO DO IT. MUST BE THIS ONE,
	REBOOT			/OR ELSE SYSTEM IS BLOWN.

DC02SUB,0
DC02S,	0			/PUTS ARGUMENT HERE
	AND	DC7760		/JUST RETURN THE STATION IN CASE OF DC02 FAILURE
	JMP I	DC02SUB		/RETURN NOW

DC02GK,	0			/CHECKS A GIVEN GROUP
	JMS	DC02SUB		/CHECK THIS ONE OUT
	SNA
	JMP	DC02GE		/NOT HERE. BOP LN AND RETURN
	ISZ	DC02CK		/WE FOUND IT. BOP PAST CALLERS ISZ.
	CLL RAL			/START TO SHIFT BITS AROUND
	ISZ I	DD02LN		/BOP AND TEST THIS LINE NUMBER
	SNL
	JMP	.-3		/NOT THIS ONE
	CLA			/ALL DONE. RETURN NOW
	JMP I	DC02CK		/AND AWAY

DC02GE,	TAD	DC0210		/BOP THE LINE NUMBER BY 10
	TAD I	DD02LN
	DCA I	DD02LN		/AND STASH AWAY
	JMP I	DC02GK		/RETURN TO CHECK NEXT SOON.

DC02ALL,17			/MASK TO CHECK FOR ALL 4 GROUPS.
DC02L1,	10			/GROUP 1 MASK
DC02L2,	4			/GROUP 2 MASK
DC02L3,	2			/GROUP 3 MASK
DC02L4,	1			/GROUP 4 MASK
DC0210,	10			/LITERAL FOR LINE BOPPING.
DD02LN,	DC02LN
DC7760,	7760			/MASKING CONSTANT FOR DC02 IN CASE OF FAILURE

	>>
	IFZERO CPU-3  <
/DECTAPE FIELD 0 DISPATCHES
	IFZERO TC01-1  <
	IFNZRO DTL20-.&4000	<GLITCH; *.-1>
	*DTL20
DTL20,	CIF DATFLD	/LEVEL 2 DISPATCHER
	JMP I .+1
	DTL21
	>>
IFZERO D680-2 <
T8MNC,	0		/MINOR LOOP COUNTER
T8LC,	0		/INTERRUPT LEVEL COUNTER
T8K9,	0		/STARTING LINE NUMBER -1

/MULTIPLE LEVEL INTERRUPT ROUTINE
/ALLOWS MULTIPLE LEVEL INTERRUPT TO THIS ROUTINE AND UNLIMITED OTHERS
T8DIS,	TT8ON
	ISZ T8LC              /LEVEL COUNTER
        JMP T8DIS3 		/2ND LEVEL INTERRUPT
        DCA T8SA              /SAVE ACCUMULATOR
        RTR                   /GET LINK
        DCA T8SVLK 		/SAVE LINK
	TAD 0		/SAVE INTERRUPT ADDRESS
	DCA T8SV0
	RIB
	DCA T8SF
T8DIS2,	CDF CIF
	TAD T8K0		/-N15
	TT8CLR			/LOAD R REG.
	CLA
	ION
        JMP I T8K1 		/JUMP TO TTI LOOP

/2ND LEVEL INTERRUPT
T8DIS3,	RMF
        ION                   /RE-ENABLE PROGRAM INTERRUPT
	JMP I 0		/RETURN TO THE MAIN PROGRAM

/RETURN FROM INPUT TTI LOOP
T8COM,    TAD T8MNC             /MINOR COUNTER, NUMBER OF LINES/5
          DCA T8CNT2          /MINOR LOOP COUNTER
          TAD T8LN              /LINE NUMBER
          TTSL+1                /SET LINE NUMBER
	  CLA
T8COM0,   TAD I T8OUTK        /OUTPUT WORD
          SNA                   /SOMETHING TO TRANSMIT
          JMP T8COM8 		/SEE IF WORD AVAILABLE
          TTO+1                 /INCR. LINE REGISTER AND OUTPUT
          DCA I T8OUTK        /STORE WORD
T8COM3,   ISZ T8OUTK          /UPDATE OUTPUT ADDR
          ISZ T8OTK2          /UPDATE 2ND BUFFER ADDRESS
          ISZ T8CNT2          /ARE ONE-FIFTH OF LINES CHECKED?
          JMP T8COM0		 /CHECK NEXT LINE

T8COM4,   TTRL                  /READ LINE NUMBER
          DCA T8LN              /SAVE LINE NUMBER
          ISZ T8CNT1          /HAVE ALL LINES BEEN CHECKED
          JMP T8COM5 		/RESET AND DISMISS
          TAD T8K2              /-5
          DCA T8CNT1          /RESET MAJOR LOOP COUNTER
          TAD T8K9              /STARTING LINE-1
          DCA T8LN              /RESET LINE NUMBER
          TAD T8K7            /T8OBF
          DCA T8OUTK          /RESET OUTPUT LINE POINTER
          TAD T8K36           /T8OBF2
          DCA T8OTK2          /RESET 2ND BUFFER POINTER
T8COM5,   IOF                   /TURN OFF INTERRUPT
          STA                   /-1
          TAD T8LC              /LEVEL COUNTER
          DCA T8LC              /RESTORE LEVEL COUNTER
          TAD T8LC              /LEVEL COUNTER
          SMA CLA                       /RESTORE AC ETC
          JMP T8DIS2            /CHECK INPUT AGAIN, ETC.
	TAD L2Q
	CIA
	TAD L2QE
	SNA CLA
	JMP T8COM9
	TAD T8SF
	AND C0100
	SZA CLA		/INTERRUPT FROM EXEC MODE?
	JMP L2CLK	/NO ,EXIT TO LEVEL 2
T8COM9,	TAD T8SFA
	JMP I RESTA
T8COM8,   TAD I T8OTK2        /PICK UP DOUBLE-BUFFERED WORD
          SZA                   /NOTHING TO SEND
          JMP .+3               /SEND NEW WORD
          TTINCR                /INCREMENT LINE REGISTER
          JMP T8COM3             /CONTINUE
          TTO+1                 /INCR. LINE REGISTER AND OUTPUT
          DCA I T8OUTK        /STORE WORD
          DCA I T8OTK2        /ZERO 2ND WORD
          JMP T8COM3             /CONTINUE

T8SF,	0
T8SV0,	0
T8SVLK,	0
T8SA,	0
T8K1,     T8IN                  /START OF TTI SERIES
T8K2,     -5                    /TO RESET MAJOR LOOP COUNTER
T8K5,     -3                    /FOR SUBTRACTION
T8K6,     1770                  /ZERO ALL BUT LINE NO
T8SFA,	T8SF
RESTA,	RESTOR
/INPUT CHARACTER PROCESSING - ENTER WITH THE
/CHARACTER IN THE AC, BITS 1-11 - ENTER VIA THE JMS
/AFTER THE TTI - LSW- CAW

T8KFLL,	0
	CLL RAR
	CLL RTR
	AND T8K11	/ZAP THE START & STOP BITS
	DCA I T8AX2	/STORE THE CHARACTER
	TTRL
	DCA I T8AX2	/STORE THE LINE NO.
	TAD T8K5	/-3
	TAD T8KFLL	/STEP THE POINTER BACK
	DCA T8CNT2	/TO THE LSW
	TAD I T8CNT2	/LSW
	AND T8K6	/1770
	DCA I T8CNT2	/SAVE LINE NO
	ISZ T8CNT2	/STEP TO CAW
	CLA CLL CML RTR	/AC=2000
	DCA I T8CNT2	/RESET THE CAW
	TTRINC		/STEP CTR WHICH CONTROLS MAX
			/NO. CHARS PER INTERRUPT
	ISZ T8INFL	/COUNT FOR THE BUFF
	ISZ T8K14	/SKP IF END OF INPUT BUFF
	JMP .+5
	TAD T8BFK	/T8IBF -1
	DCA T8AX2	/RECYCLE THE BUFFER
	TAD T8NL	/-N
	DCA T8K14	/RESET THE COUNTER
/NOW REMEMBER THAT WE HAVE AN INPUT CHAR
	ISZ	ECHOFL	/DO WE ALREADY KNOW WE HAVE ONE?
	JMP I T8KFLL	/YES, SO OKAY TO EXIT
	TAD ECHOA
	DCA I	L2Q	/NO, SO QUEUE AN ECHO REQUEST
	JMP I T8KFLL	/XIT
ECHOA,	ECHO
ECHOFL,	-1

/CLOCK TIME

INT81A,	INT81
CLKITA,	CLKIT
L2CLK,	TAD EXITA
	DCA I CLKITA
	TAD T8SVLK
	DCA L2SVLK
	TAD T8SA
	DCA L2SA
	TAD T8SV0
	DCA L2SV0
	TAD T8SF
	JMP I INT81A
	>
	PAGE
/RETURN ADDRESS OF LINKED TABLE ENTRY
/CALL	TAD TABLE ENTRY ADDRESS
/	GETJTA
/	 ENTRY NAME
/	RETURN

GETJTB,	0
	DCA GETJT1	/SAVE JOBTABLE ADDRESS
	TAD I GETJTB	/ENTRY #
	DCA GETJT2
	RDF		/FIELD CALLED FROM
	TAD C6203
	DCA GETJT3	/SO WE CAN GET BACK
	DATFLD		/CHANGE TO DATA FIELD
GETJ1,	TAD I GETJT1	/GET JOBTBL ENTRY
	SNA		/LINK 0?
	JMP GETJ3	/YES - RETURN 0
	DCA GETJT1	/NO. JOB DATA ADDRESS
	TAD GETJM7
	TAD GETJT2	/ARE WE IN PROPER BLOCK?
	SPA		/ENTRY<7?
	JMP .+3		/YES
	DCA GETJT2	/NO. LINK TO NEXT
	JMP GETJ1	/AND TRY AGAIN
	CLA
	TAD GETJT2	/INDEX INTO BLOCK
	TAD GETJT1	/START OF BLOCK
	IAC
GETJ3,	ISZ GETJTB	/SKIP CALLING ARGUMENT
GETJT3,	0		/BACK TO CALLING FIELD
	JMP I GETJTB

GETJT1,	0
GETJT2,	0
GETJM7,	-7
/GET JSFX
/CALL	TAD FILE #
/	JMS GETJFX
/	RETURN WITH JSFX IN AC

GETJFX,	0
	AND C0003	/FILE # ONLY
	CMA
	DCA GETJF0	/-SHIFT COUNT
	STL RAR
	RAR
	ISZ GETJF0	/DONE?
	JMP .-2
	JMP I GETJFX	/YES, EXIT WITH BIT SET IN AC
/RESTORE JOB REGISTERS
/CALL	TAD JOB #
/	RESJOB
/	RETURN

QUANTA,	QUANT
RESMSK,	FIP+SI+37

GETJF0,
RESJO0,	0
	AND RESMSK	/CLEAR CORE STATUS BITS
	DCA JOB		/AND SAVE IN JOB
	TAD JOB
	AND C0037
	TAD JOBTBA
	DCA RESJO1	/JOBTBL POINTER FOR THIS JOB
	DATFLD
	TAD I RESJO1	/GET ADDRESS OF JOB DATA AREA
	DCA I CJOBDA	/AND SAVE IN FIELD 1
	CDF
	TAD QUANTA	/INITIALIZE HIS QUANTUM RUN TIME
	DCA JOBTIM
	DCA L2SV0	/SET PC=0 IN ANTICIPATION OF PHANTOMS
	TAD JOB		/IS IT A PHANTOM?
	AND C0600
	SZA CLA
	JMP I RESJO0	/YES; WE'RE RESTORED!
/
/ NOW RESTORE THE EAE REGISTERS IF THEY EXIST
/
	IFZERO EAE-20 <
		IFZERO CPU-2 <
	SWAB		/PUT EAE IN MODE B
	GETJTW		/PICK UP MODE, GT, & SC
	 JOBREG+1
	MQL		/ & SAVE THEM IN MQ
	TAD C1000
	MQA		/IF THE 'GT' FLAG WAS SET BEFORE,
	SAM		/ THIS WILL SET IT NOW
	CLA MQA ACS	/LOAD SC ALL THE WAY FROM MQ
	MQA		/GET MODE BACK INTO AC
	SMA CLA		/WAS IT SET?
	SWBA		/NO - SET MODE 'A'
		>
		IFNZRO CPU-2 <
	GETJTW		/PICK UP SC
	 JOBREG+1
	AND C0037	/ZAP ALL BUT THE SEQUENCE-COUNT
	CMA		/COMPLEMENT AND STORE FOR
	DCA .+2		/  OLD-STYLE EAE
	SCL		/LOAD SC
	0
		>
	>
	IFZERO MQREG-1 <
	GETJTW		/RESTORE MQ
	 JOBEAE
	MQL
	>
	TAD RESJO1
	GETJTA		/GET ADDDRESS OF PC IN JOB DATA AREA
	 JOBREG
	DCA RESJO1
	BLT		/MOVE PC, AC, & LINK TO LEVEL-2 REGISTERS
	 DATFLD
RESJO1,	 0
	 CDF
	 L2SV0
	 -3
	JMP I RESJO0	/ALL RESTORED
/CLEAR BUFFER
/CALL	TAD DDB ADDRESS
/	JMS CLRBUF
/	RETURN

	IFNZRO DDBINP-4	<GLITCH; *.-1>
CLRINP=	C0004	/DDBINP
	IFNZRO DDBOUP-DDBINP-2	<GLITCH; *.-1>
CLROUP=	C0002	/DDBOUP-DDBINP

TTYSR1,	
CLRBUF,	0		/ENTER WITH DDB ADDRESS
	TAD CLRINP	/...+4
	DCA CLRBU1	/POINTS TO FILL POINTER
	DATFLD
	DCA I CLRBU1	/FILL POINTER = 0
	TAD CLRBU1
	TAD CLROUP	/...+2
	DCA CLRBU1	/POINTS TO EMPTY POINTER
	TAD I CLRBU1
	CDF
	SNA		/EMPTY PTR=0?
	JMP CLRBU2	/YES
	RETBLK		/NO - RETURN THE BUFFER
	JMP .-3		/KEEP RETURNING BUFFERS
CLRBU2,	DATFLD
	DCA I CLRBU1	/CLEAR EMPTY POINTER
	CDF
	JMP I CLRBUF	/AND RETURN
/SEARCH FOR TTY
/CALL	TAD JOB #
/	TTYUSE
/	 0 FOR INPUT BUFFER, 1 FOR OUTPUT BUFFER
/	RETURN WITH DDB ADDR IN AC, 0 IF NOT FOUND

CLRBU1,
TTYSRC,	0
	AND C0037	/GET JOB #
	TAD TTYTBA	/START OF TTY TABLE
	DCA TTYSR1
	DATFLD
	TAD I TTYSR1	/GET UNIT # FROM TABLE
	CDF
	CLL RAL		/POSITION IN DEVTBL
	TAD DEVTBA	/POINTER TO DEVTBL
	TAD I TTYSRC	/INPUT OR OUTPUT
	DCA TTYSR1
	DATFLD
	TAD I TTYSR1	/DDB ADDRESS
	CDF
	ISZ TTYSRC	/INDEX PAST ARGUMENT
	JMP I TTYSRC

TTYTBA,	TTYTBL

/FIELD 0 DISPATCH FOR  PEEK IOT

UPEEK,	GETJTW		/GET HIS STATUS-WORD
	 JOBSTS
	AND UJPRIV
	SNA CLA		/IS HE PRIVILEGED NOW?
	JMP I UUOERA	/NO - "ILLEGAL IOT"
	CIF+10		/YES - OFF TO FIELD 1
	JMP I .+1
	UPEEK1
UJPRIV,	JSPRIV
	PAGE

	IFZERO   D680-2	<
TEST,	IOF		/TO BE ON THE SAFE SIDE
	DCA X		/STORE THE CHARACTER TO BE PUT OUT (BELL/XOFF)
	TAD TCHAR		/TEST TCHAR TO SEE IF FLAG IS EXPECTED
	SZA CLA
	JMP Y		/YES, PUT THE CHAR IN TCHAR TO WAIT FOR THE FLAG
	TAD X		/NO FLAG, GET THE CHAR TO BE PUT OUT
	TLS		/SEND IT OUT
TEST2,	DCA TCHAR		/REMEMBER IT WAS SENT
	ION
	JMP I TEST3		/THIS ROUTINE IS CALLED ONLY ONCE!!!
Y,	TAD X		/HAVE TO WAIT FOR THE FLAG, GET THE CHAR
	AND C0377		/REMOVE BIT 0 WHICH IS ALREADY THERE!!!
	JMP TEST2		/GO BACK STORE IT IN TCHAR TO BE SENT LATER

X,	0
TEST3,	CHOUT2		>

UCSTO,	0
	DCA X1		/SAVE -3 WHICH IS IN AC FOR COUNT
Y1,	UDF		/UP TO USER FIELD
	TAD I L2SA	/GET BITS TO CLEAR
	CMA
	DATFLD
	AND I JOBSWA	/CLEAR THEM
	DCA I JOBSWA	/SAVE NEW VALUE
	ISZ L2SA	/BUMP POINTER
	NOP
	ISZ JOBSWA	/BUMP POINTER
	ISZ X1		/COUNT, 3 STATUS WORDS TO CLEAR
	JMP Y1
	JMP I UCSTO	/RETURN
X1,	0
/ROUTINE TO DECREMENT THE DISC ACTIVITY-COUNT &
/START UP THE NEXT TRANSFER IF THERE IS ONE.
DSKCON,	0
	CLA CLL CMA
	TAD DSBUSY
	DCA DSBUSY	/DECREMENT COUNT
	TAD DSBUSY
	SMA CLA		/IS IT NOW -1?
	JMS I FIUSER	/NO - START THE NEXT TRANSFER
	JMP I DSKCON	/YES - THEN THERE IS NO MORE

/ROUTINE TO SET THIS JOB IN 'BONUS' SO THAT IT HAS
/SCHEDULING PRIORITY.
DELBON,	0
	JMS I PTJOBA	/GET HIS JOB NUMBER
	DCA BONUS
	TAD BONUS	/RETURN WITH JOB # IN AC
	JMP I DELBON

PTJOBA,	DEVJOB

/TAKE CARE OF DUPLEX AND UNDUPLEX IOT'S

UDUP,	TAD C0200	/DUPLEX BIT IN DDB WORD 1
UUND,	DCA WS0		/WS0 CONTAINS BIT TO ADD FOR BOTH IOT'S
	TAD JOB
	TTYUSE		/FIND INPUT DDB
	 0		/ (INPUT SIDE)
	DCA WS1		/ADDRESS OF DDB
	DATFLD
	TAD I WS1	/WORD ONE OF DDB
	AND CMDUPL	/CLEAR DUPLEX BIT
	TAD WS0		/SET IT AS CALLED FOR
	DCA I WS1
	UUOEXT

CMDUPL,	-DUPL-1
	IFZERO CPU-3 <
DC02EN,	0			/THIS SUBROUTINE ENABLES ALL STATIONS AND ALL GROUPS
	CLA CMA
	MTON
	CLA			/THEY'RE ENABLED NOW
	JMP I	DC02EN		/BYE BYE


DC02SL,	0			/THIS ROUTINE SELECTS A GIVEN STATION AND GROUP
	TAD	DC7777		/ENTERED WITH LINE NUMBER IN AC.
	DCA	DC02EN		/SAVE FOR A SECOND
	TAD	DC17
	MTON			/DISABLE ALL GROUPS
	CLA
	TAD	DC02EN		/REGET THE LINE NUMBER
	RTR
	RAR
	AND	C0003		/JUST MAJOR GROUP NUMBER
	CMA			/ONE'S COMP NEGATE
	DCA	DCTEMP		/NOW PREPARE TO SET UP THE GROUP BITS.
	TAD	DC0220		/GROUP 1 BIT OFFSET ONE.
	CLL RAR			/NOW SHIFT THE GROUP BIT ACCROSS
	ISZ	DCTEMP		/DONE?
	JMP	.-2		/NOPE
	DCA	DCTEMP		/SAVE GROUP BIT NOW IN DCTEMP
	TAD	DC02EN		/REGET THE LINE NUMBER
	AND	C0007		/JUST THE STATION BITS NOW
	CMA CLL CML		/SET THE LINC TO 1 WHILE NEGATING IT
	DCA	DC02EN
	RAR			/ROTATE STATION BIT
	ISZ	DC02EN		/DONE
	JMP	.-2		/NOPE. LOOP
	TAD	DCTEMP		/ADD IN THE GROUP BIT
	MTON			/SELECT IT, BABY
	CLA
	JMP I	DC02SL		/AND RETURN NOW

DCTEMP,	0
DC17,	17
DC7777,	-1

TSER,	TAD	DC02LN		/GET THE LINE NUMBER NOW
	TAD	TBUFF		/GET THE TTY BUFFER NOW
	DCA	KTBUF		/SAVE FOR A SECOND NOW
	TAD I	KTBUF		/DOES HE HAVE A CHARACTER THERE?
	SPA CLA
	JMP	TSERX		/NOPE. JUST CLEAR THE FLAG
	TAD I	KTBUF		/GET THE CHARACTER NOW
	JMS I	TSERPP		/OUTPUT IT USING THE SPECIAL LITTLE ROUTINE NOW
DC02LN,	0			/LINE NUMBER
	CLL CML RAR		/SET THE HIGH ORDER BIT ON[I HOPE THIS WORKS]
	DCA I	KTBUF		/STASH AWAY
	JMS	DC02EN		/ENABLE THE TTY'S NOW
	DISMIS			/DISMIS IT.

TSERPP,	JBDC02			/POINTER TO THE CHARACTER PUTTER

TSERX,	TAD	DC02LN		/GET THE LINE NUMBER NOW
	SZA
	JMP	TSERX1		/IT'S THE DAMN DC02. WHAT A PAIN
	TCF
	JMP	TSERC		/CLEAN UP AND EXIT

TSERX1,	JMS	DC02SL		/SELECT THE RIGHT TTY
	MTCF
	JMP	TSERC		/CLEAN UP AND EXIT

KSER,	TAD	DC02LN		/GET THE LINE NUMBER NOW
	TAD	KBUFF
	DCA	KTBUF		/PLAY AROUND WITH THE BUFFER POINTERS
	TAD	DC02LN		/REGET THE LINE NUMBER NOW
	SZA
	JMP	KSSER1		/DC02 INPUT
	KRB			/READ IN THE CHARACTER NOW
	JMP	KSSER2		/COMMON FIXER

KSSER1,	JMS	DC02SL		/SELECT THE LINE NOW
	MKRB			/READ IN THE CHARACTER NOW

KSSER2,	TAD	C1000		/FORCE THE CHARACTER NON-ZERO
TSERC,	DCA I	KTBUF
	JMS	DC02EN
	ISZ	ECHOFL
	DISMIS			/NOT ECHOING
	TAD	.+2
	DISMIS			/RETURN NOW
	ECHO			/WITH ECHO POINTER IN THE AC.
ECHOFL,	-1

KTBUF,	0
DC0220,	20			/GROUP STARTER UPPER
	>
	IFNZRO CORTBL-.&4000	<GLITCH; *.-1>
	*CORTBL
/
/THIS IS THE FIELD ALLOCATION TABLE
/THE LOCK-BITS ARE REMOVED BY INIT AS A FUNCTION
/OF THE NUMBER OF USER FIELDS.
CORTBL,	LOCK	/DATFLD
	LOCK	/FIELD 2
	LOCK	/FIELD 3
	LOCK	/FIELD 4
	LOCK	/FIELD 5
	LOCK	/FIELD 6
	LOCK	/FIELD 7

/
/THE FOLLOWING IS THE LEVEL-2 ACTIVITY QUEUE.
L2QTB,	ZBLOCK 20

	IFZERO D680 <
TIBUFF,	ZBLOCK NULINE+1	/INPUT CHAR BUFFER FOR EACH LINE
TOBUFF,	ZBLOCK NULINE+1	/OUTPUT CHAR BUFFER
		IFNZRO CPU-3 <
TIDEV,	ZBLOCK NULINE+1	/INPUT DEVICE CODE TABLE
TODEV,	ZBLOCK NULINE+1	/OUTPUT DEVICE CODE TABLE
		>
		IFZERO CPU-3 <
TIDEV,	0
TODEV,	0
		>
TYBEND=	.		/END OF LINE-CONTROL TABLES
	>

	IFZERO  D680-2  <

	*T8OBF
	ZBLOCK NULINE

	*T8OBF2
	ZBLOCK NULINE

	*T8IBF
	ZBLOCK NULINE+NULINE	/CHARACTER / LINE #

/ ABOVE AREA IS FOR 680 BUFFER


	*T8IN
	TTI
	0		/LSW  LINE #
	2000		/CAW
	JMS I T8K99		/
	TTI
	10		/LSW  LINE #
	2000		/CAW
	JMS I T8K99		/
	TTI
	20		/LSW  LINE #
	2000		/CAW
	JMS I T8K99		/
	TTI
	30		/LSW  LINE #
	2000		/CAW
	JMS I T8K99		/
	TTI
	040		/LSW  LINE #
	2000		/CAW
	JMS I T8K99		/
	TTI
	050		/LSW  LINE #
	2000		/CAW
	JMS I T8K99		/
	TTI
	060		/LSW  LINE #
	2000		/CAW
	JMS I T8K99		/
	TTI
	070		/LSW  LINE #
	2000		/CAW
	JMS I T8K99		/
	TTI
	0100		/LSW  LINE #
	2000		/CAW
	JMS I T8K99		/
	TTI
	0110
	2000
	JMS I T8K99		/
	TTI
	0120		/LSW  LINE #
	2000		/CAW
	JMS I T8K99		/
	TTI
	0130		/LSW  LINE #
	2000		/CAW
	JMS I T8K99		/
	TTI
	0140		/LSW  LINE #
	2000		/CAW
	JMS I T8K99		/
	TTI
	0150		/LSW  LINE #
	2000		/CAW
	JMS I T8K99		/
	TTI
	0160		/LSW  LINE #
	2000		/CAW
	JMS I T8K99		/
	TTI
	0170		/LSW  LINE #
	2000		/CAW
	JMS I T8K99		/
	TTI
	0200		/LSW  LINE #
	2000		/CAW
	JMS I T8K99		/
	TTI
	0210		/LSW  LINE #
	2000		/CAW
	JMS I T8K99		/
	TTI
	0220		/LSW  LINE #
	2000		/CAW
	JMS I T8K99		/
	TTI
	0230		/LSW  LINE #
	2000		/CAW
	JMS I T8K99		/


	*TYBEND-1
	JMP I T8K8


	>
	IFNZRO 7323-.&4000	<GLITCH; *.-1>
	*7323

/ROUTINE TO FIND THE BEST FIELD TO SWAP. THIS ALGORITHM
/GIVES A SYSTEM PHANTOM PRIORITY OVER NON-RUNNABLE JOBS
/BUT NOT OVER RUNNABLE JOBS. SINCE INACTIVE JOBS THUS TEND
/TO BE SWAPPED OUT, MORE CORE IS AVAILABLE FOR ACTIVE JOBS
/AND LESS SWAPPING NEEDS TO BE DONE.

SCNSWP,	TAD SCNSAV
	DCA I SCNPTR	/SET OUR OWN POINTER IN 'CORE'
	TAD I SCNCNT
	DCA WS0		/SET FIELD COUNTER
SCN1,	CORE		/FIND AN UN-PROTECTED FIELD
	 FSWP+LOCK+NOTRUN+FIP+SI+FIX
	JMP SCN2	/NONE THERE
	AND C0007
	DCA FORCE	/SAVE THE FIELD NUMBER
	TAD FORCE
	TAD CORTBA
	DCA JOBSWA
	TAD I JOBSWA	/GET THE 'CORTBL' ENTRY
	AND C0037	/ AND PICK OFF THE JOB NUMBER
	RUNABL		/IS THE JOB RUNNABLE?
	JMP SCN3	/NO - FORCE IT OUT
	ISZ WS0
	JMP SCN1	/YES - TRY AGAIN
SCN2,	DCA FORCE	/CLEAR 'FORCE'
	CORE		/CHECK FOR NON-BUSY PHANTOM
	 FSWP+LOCK+NOTRUN+37
	SKP
	JMP I SCN12A	/OK - JUST LOAD OVER PHANTOM
	CORE		/NO - LOOK FOR ANY VALID FIELD
	 FSWP+LOCK+NOTRUN+FIP+SI+FIX
	JMP I SCN13A	/NOTHING TO SWAP - FIND NEW JOB
	AND C0007
	DCA FORCE	/FOUND ONE - SAVE THE FIELD NUMBER
SCN3,	TAD I SCNPTR	/PICK UP AND SAVE THE SEARCH POINTER
	DCA SCNSAV	/ SO WE CAN SWAP FAIRLY
	JMP I .+1	/THEN GO SET UP TO SWAP OUT
	SCHFR1

SCNCNT,	CORCNT
SCNPTR,	CORTBP	/SEARCH POINTER IN 'CORE'
SCNSAV,	CORTBL+1
SCN12A,	SCHE12
SCN13A,	SCHE13

/CODE TO HANDLE SEVERAL SIMPLE RESIDENT-IOTS. ALL
/THEY DO IS RETURN A SINGLE VALUE IN THE AC.
UUSE,	TAD JOB		/RETURN JOB # IN AC
	JMP UUSAC2

USIZE,	TAD SEGSIZ	/RETURN SEGMENT SIZE IN AC
UUSAC2,	DCA L2SA
	UUOEXT
/PAPER TAPE PUNCH SERVICE FOR TSS/8

UPTP,	CIF 10		/FIELD 1 HAS THIS ROUTINE 
	JMS I	PTPCHK		/DOES HE OWN DEVICE?
	DEVTBE+1		/POINTER TO PUNCH ENTRY IN DEVTBL
	JMS	PTPINI		/YES; INITIALIZE IT.

	JMS I	PTPIOT		/ANALYZE IOT
	JMP	UPST		/PUNCH STRING
PTPFL,	JSPTP
	JMP	UPPWX		/FLAG TEST AND FLAG NOT SET

	SNA CLA			/PCF OR PLS?
	JMP	UPPX		/NO - EXIT WITH NO WAIT
	TAD	PTPCNT		/YES-IS THERE ROOM?
	SNA CLA
	JMP	UPPWAT		/NO - CLEAR FLAG AND REDO
	DATFLD			/YES - PUT CHARACTER IN BUFFER
	IOF			/DON'T LET A PUNCH INTERRUPT SCREW US
	TAD	L2SA
	DCA I	PTPFIL
	ISZ PTPFIL
	ISZ	PTPCNT		/ONE LESS SLOT IN BUFFER
PTPEMP,	NOP			/IF IT GOES TO 0 WE DON'T CARE
	JMS PTPGO		/START PUNCH IF NECESSARY
	JMP UPPX		/EXIT WITH OUT WAITING
UPPWAT,	STA			/BACK UP USER'S PC TO POINT TO THIS
	TAD	L2SV0		/IOT
	DCA	L2SV0

UPPWX,	TAD PTPFL		/CLEAR PUNCH FLAG
UPPX,	UUOEXT

UPST,	TAD	PTPCNT		/PUNCH STRING
	SNA CLA			/ROOM IN BUFFER
	JMP	UPPWAT		/NO - EXIT AND WAIT
	UDF			/YES - SELECT USER FIELD
	TAD I	L2SA		/GET CHAR COUNT
	SNA CLA			/ANYTHING TO DO?
	JMP	PTP3A		/NO (CHAR COUNT IS ALREADY=0)
	TAD	L2SA		/YES
	IAC
	DCA	WS1		/POINTS TO WORD 2 OF PARAMETERS
	TAD I	WS1
	IOF
	DCA	AXS1		/ADDRESS-1 OF DATA TO PUNCH
PTP2A,	TAD I	AXS1		/GET CHARACTER FROM USER AREA
	DATFLD			/SELECT BUFFER FIELD
	DCA I	PTPFIL		/PLACE IN BUFFER
	ISZ PTPFIL
	UDF			/SELECT USER FIELD
	ISZ	PTPCNT		/STILL ROOM?
	JMP	PTP1A		/YES
	TAD	AXS1		/NO - UPDATE USER'S PARAMETERS
	DCA I	WS1		/STARTING ADD-1
	ISZ I	L2SA		/UPDATE COUNT OF CHARACTERS TO PUNCH
PTPFIL,	NOP			/OUR THANKS TO CARLETON COLLEGE FOR THIS ONE
	DCA	L2SA		/CLEAR HIS AC
	JMS PTPGO		/START THE PTP
	JMP	UPPWX		/WAIT FOR BUFFER TO DRAIN

PTP1A,	ISZ I	L2SA		/ANYTHING LEFT TO PUNCH?
	JMP	PTP2A		/YES, DO ANOTHER CHARACTER
	JMS PTPGO
PTP3A,	DCA	L2SA		/NO, ALL DONE
	JMP I	.+1		/EXIT WITH PC INCREMENTED
	UUOEX2
PTPGO,	0
	ISZ	PTPBSY		/PUNCH ON?
	JMP PTPION		/YES - PINT WILL GET THIS CHAR
	DATFLD
	TAD I	PTPEMP		/NO - START IT
	CDF
PTP2,	PLS		/PUNCH CHAR
PTPBSZ,	7600		/-SIZE OF PUNCH BUFFER (ALSO 'CLA')
	TAD RACE3A	/GET PARAMETER ADDRESS
	JMS I PTPTIM
PTPION,	ION		/TURN INTERRUPT BACK ON
	JMP I	PTPGO		/RETURN
RACE3A,	RACE3

PTPINI,	0			/INITIALIZE PUNCH BUFFER
	TAD	PTPBSZ		/-MAX# CHARS IN BUFFER
	DCA	PTPCNT
	TAD	C0200		/FILL POINTER TO START
	DCA	PTPFIL
	TAD	C0200		/EMPTY POINTER TO START
	DCA	PTPEMP
	JMP I	PTPINI		/RETURN

PTPIOT,	UKT1
PTPCNT,	0
PTPBSY,	-1	/-1 FOR PUNCH OFF; .GE.=0 FOR ON
/PAPER TAPE PUNCH INTERUPT SERVICE

PTPINT,	ISZ	PTPEMP		/BUMP EMPTY POINTER
	TAD	PTPFIL
	CIA
	TAD	PTPEMP
	SMA CLA			/HAS EMPTY PTR CAUGHT FILL PTR
	JMP PINT1	/YES - STOP PUNCH
	DATFLD		/NO - GET CHAR AND PUNCH
	TAD I PTPEMP
PTP3,	PLS		/LOAD & PUNCH
	CLA CLL
PTP4,	PSF		/FLAG READY AGAIN?
	DISMIS		/NO

	IFZERO TC01-1 <
	JMS I DTCHK2	/YES - BUT IS THE DECTAPE READY NOW?
	>
	JMP PTPINT	/NO - GO LOAD NEXT CHAR TO SEND
	IFZERO TC01 <
	NOP		/ (SO 'PTP5' DOESN'T MOVE)
	>

PTP5,
PINT1,	PCF		/CLEAR PUNCH FLAG
	JMS I PTPL3	/INDICATE PUNCH IS OFF & TURN OFF TIMER
	TAD .+2		/SCHEDULE LEVEL 2 SERVICE
	DISMIS
	PTPL2

PTPL3,	PLRACE
PTPTIM,	PTTIM
	IFZERO TC01-1 <
DTCHK2,	DTCHK
	>
/ROUTINE TO SET FLAG IN USER STATUS REG AND EXIT.
/CALLING SEQUENCE:
/	TAD (FLAGS TO SET)
/	LINK = 0 FOR EXIT THRU EXIT
/	LINK = 1 FOR EXIT THRU UUOEXT
/	JMS PTSTAR
/	 PTR TO DEVTBL ENTRY FOR THIS DEVICE

PTSTAR,	0
	DCA PTFLAG	/SAVE FLAGS TO SET
	RAR
	DCA PTST1	/SAVE INCOMING LINK
	TAD I PTSTAR
	DCA WS1		/POINTS TO DEVTBL
	DATFLD
	TAD I WS1
	SNA		/IS THIS JOB STILL AROUND?
	JMP PTEXIT	/NO
	JMS I PTPBON	/GET JOB # FROM DDB & SET 'BONUS'
	TAD JOBTBA	/START OF JOB TABLE
	GETJTA		/GET ADDRESS OF STR1
	 JOBSTS+1
	DATFLD		/FIELD 1
	IOR		/OR IN FLAGS
PTFLAG,	 0
PTEXIT,	TAD PTST1
	SMA CLA		/WAS LINK SET ON ENTRY?
	EXIT		/NO - TAKE LEVEL-2 EXIT
	UUOEXT		/YES - TAKE RESIDENT-IOT EXIT

PTPBON,	DELBON
PTST1=	WS0
	PAGE
	
SWPIO,	0
	CLA CLL CMA RTL	/=3 IN AC
	DCA DSERRI	/#OF TRIES
	TAD FINISH
	SMA CLA		/WHICH WAY DO WE SWAP?
	JMP INSET	/SWAP IN
	JMS SWOUT	/SWAP OUT
	JMP I SWPIO	/RETURN

INSET,	JMS SWPIN	/SWAP IN
	JMP I SWPIO	/RETURN

SWPIN,	0
	DCMA		/TO STOP THE DISC
	TAD SWINA 	/RETURN ADDRESS FOR INTURRUPT CHAIN
	DCA I DSWATA	/SAVE IT
	TAD INTRC	/GET THE TRAC # TO BE READ IN

	IFZERO RF08-40 <
	TAD SQREQ	/FIELD TO BE USED
	DEAL
	CLA
	NOP		/JUST FOR PROPER LENGTH
	>
	IFZERO RF08 <
	DXAL
	TAD SQREQ	/FIELD TO BE SWAPPED IN
	TAD C0500	/ENABLE INTERRUPT ON ERROR AND ON COMPLETION
	DIML
	>
	DCA DSWC	/WORD COUNT
	CMA
	DCA DSMA	/CORE ADDRESS
	DMAR
	JMP I SWPIN
SWINA,	SWINR		/SWAPIN RETURN ADDRESS

SWOUT,	0
	DCMA		/TO STOP THE DISC IN CASE OF PROBLEM
	TAD SWOUA	/RETURN ADDRESS FOR INTERRUPT CHAIN
	DCA I DSWATA	/SAVE IT
	TAD OUTTRC	/GET THE TRAC # TO BE SWAPPED OUT
	IFZERO RF08-40 <
	TAD SQREQ	/FIELD TO BE SWAPPED OUT
	DEAL
	CLA
	NOP
	>
	IFZERO RF08 <
	DXAL
	TAD SQREQ	/FIELD TO SWAPPED OUT
	TAD C0500	/INTERRUPT ON ERROR AND ON COMPLETION
	DIML
	>
	DCA DSWC	/WORD COUNT
	CMA
	DCA DSMA	/CORE ADDRESS
	DMAW
	JMP I SWOUT


SWOUA,	SWOUTR		/RETURN ADDRESS AFTER SWAP OUT

SWOUTR,	JMP SOUTR1	/ERROR
	TAD FINISH	/FINISH = -FIELD # AT THIS STAGE MAKE IT +
	CIA
	DCA FINISH	/SAVE IT
	CLA CLL CMA RTL	/ -3
	DCA DSERRI	/# OF TRIES FOR SWAP IN
SOUT5,	JMS SWPIN
	DISMIS		/GO BACK TO WHAT WE WERE DOING
SOUTR1,	ISZ DSERRI	/3 TRIES BEFORE GIVING UP
	JMP SOUTR2
SOUTR4,
		IFZERO RF08  <
	DIMA		/GET THE ERROR FLAGS
	AND C0004	/IS IT DUE TO EAE?
	SNA CLA
			>
	TAD NORMAL	/NO, DISC IN REAL TROUBLE
	TAD SLEP2A	/EAE, PUT TO SLEEP
	JMP NOTOK	/JMP TO COMMON PART  SAVE CORE!!!

NORMAL,	-SLEEP2+SWERR
SLEP2A,	SLEEP2

SOUTR2,	JMS SWOUT	/TRY AGAIN TO SWAP OUT
	DISMIS

SWINR,	JMP SWIN1	/ERROR
	TAD SWPGD2	/OK WHAT TO DO NEXT? L2Q
	JMP NOTOK	/COMMON CODE
SWIN1,	ISZ DSERRI	/TRY 3 TIMES ON ERROR
	JMP SOUT5
	JMP SOUTR4	/GIVE UP
/START DISC TRANSFER
/CALL	TAD ADDRESS OF PARAMETERS
/	DSGO
/	RETURN

DSPAR=	12

DSGO0,	0
	DCA DSPARM
	CLA CLL CMA RTL
	DCA DSERRI
	JMS DSTRYA
	JMP I DSGO0

DSTRYA,	0
	DCMA		/CLEAR THE FLAG & STOP THE DISC
	TAD DSRETA
	DCA I DSWATA
	CLA CMA		/ADDRESS OF PARA-1 FOR INDEX REGISTER
	TAD DSPARM
	DCA DSPAR
	DATFLD
	TAD I DSPAR	/FUNCTION
	DCA DSRORW
	TAD I DSPAR	/DISC EXTENSION

	IFZERO RF08-40 <
	CLL RTL
	CLL RAL
	TAD I DSPAR	/MEMORY EXTENSION
	CLL RAL
	DEAL
	CLA
	>
	IFZERO RF08 <
	CLL RTR
	DXAL
	TAD I DSPAR
	CLL RAL
	AND C0070
	TAD C0500
	DIML		/LOAD INTERRUPT ENABLE AND MEMORY EXTENSION
	>
	TAD I DSPAR
	DCA DSWC
	TAD I DSPAR
	DCA DSMA
	TAD I DSPAR
	CDF
DSRORW,	0
	JMP I DSTRYA

DSPARM,	0
DSERRI,	0
DSRETA,	DSRET
DSWATA,	DSWAIT

	IFNZRO 7750-.&4000	<GLITCH; *.-1>
	*7750
	7751	/FOR LOADING INTO FIELD 0 ON INITIALIZATION
	7751	/(SINCE THE 4K TRANSFER OVERWRITES THE DATA BREAK LOCATIONS)

SLEEPA,	SLEEP
C0500,	500
	0		/FOR DECTAPE SERVICE
	0		/FOR DECTAPE SERVICE
DSERR1,	JMS DSTRYA
	DISMIS
DSRET,	JMP .+3		/ERROR
	IAC
	JMP OK		/OK
	ISZ DSERRI
	JMP DSERR1

	IFZERO RF08 <
	DIMA
	AND C0004	/IS DRL FLAG ON?
	SNA CLA
	JMP OK		/NO, NORMAL ERROR RETURN
	TAD SLEEPA	/YES, EAE MAY BE THE REASON PUT IT TO SLEEP
	JMP NOTOK
	>
OK,	DATFLD
	TAD I DSPAR
NOTOK,	CDF
	DCMA
	DISMIS		/RETURN TO MONITOR

DSWC=	7750
DSMA=	7751

/////	$$$$$
	$$$$$
